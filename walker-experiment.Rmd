---
title: "Walker experiment"
author: "Lisa Ko√ümann, Alexander (Sasha) Pastukhov"
date: "31 1 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

extrafont::loadfonts(quiet = TRUE)
```

```{r libraries}
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpubr)
library(glue)
library(ggplot2)
library(grid)
library(readr)
library(stringr)
library(tibble)
library(tidyr)
```



```{r Tabula rasa}
rm(list=ls())
```


```{r Custom plotting theme}
plot_theme <- 
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
```

# Importing data
```{r Import}
read_walker_csv <- function(filename){
  read_csv(filename, 
           col_types=cols(
                .default = col_double(),
                Participant = col_character(),
                Session = col_character(),
                Block = col_double(),
                OnsetDelay = col_double(),
                Condition = col_character(),
                Percept = col_character(),
                Time = col_double()
              )) %>%
    mutate(SessionTag = ifelse("Shift" %in% names(.), "Addendum", "Main"))
}


reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*walker*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_walker_csv(.$filename[1])) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Session, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%

  # 4. Drop "end" Percept
  filter(Percept != "end")%>%
  
  #5. Renaming Percepts
  mutate(Percept=as.factor(Percept),
         Percept=fct_recode(Percept, "congruent"="up", "incongruent"="down"))
         
  
walker_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Walker ambiguity"))

```


## Distance vertical condition
```{r}
vertical_distance <- 
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Distance"))%>%
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"0", "1", "2", "3", "4")) %>%
  
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting vertical distance
ggplot(data=vertical_distance,
       aes(x=Distance, group=Distance, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         xlab("Distance [%]")
```

```{r fitting vertical distance as a continous variable}
set.seed(45950)
vertical_distance_fit <- brm(PcongruentAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=vertical_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r vertical distance importance via loo}
vertical_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=vertical_distance)

vertical_distance_fit <- add_criterion(vertical_distance_fit, "loo", reloo=TRUE)
vertical_distance_null_model <- add_criterion(vertical_distance_null_model, "loo", reloo=TRUE)

loo_compare(vertical_distance_null_model, vertical_distance_fit, criterion = "loo", model_names = c("intercept", "Distance"))
loo_model_weights(vertical_distance_null_model, vertical_distance_fit, model_names = c("intercept", "Distance"))
```

```{r plot vertical distance continuous predictions}
vertical_distance_fit_predictions <- predict(vertical_distance_fit,
                                             newdata = data.frame(Distance= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(Distance= seq(0, 4.2, length.out = 100))

vertical_distance_plot_main <-
  ggplot(data=vertical_distance_fit_predictions, # lisa, come back here and figure out why you get an error message
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=vertical_distance, method="tukeyDense", width=0.1,
                aes(x=Distance, group=Distance, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Distance [%]", breaks = unique(vertical_distance$Distance)) +
  plot_theme

vertical_distance_plot_main
```

```{r plotting vertical distance slope}
vertical_distance_plot_slope <- 
  posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  ggplot(aes(x=b_Distance)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Distance]))

vertical_distance_plot_slope
```

```{r number of values above zero vertical distance slope}
posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1))
```
## Vertical distance as factor
```{r fitting vertical distance as factor}
set.seed(96251)
vertical_distance_as_factor_fit <- brm(PcongruentAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(), 
                              data=vertical_distance,
                              prior=c(prior(normal(0,10), class="b")))
```

```{r plotting pariwise comparisons for individual levels of vertical distance}
samples_vertical_distance_as_factor_fit <- posterior_samples(vertical_distance_as_factor_fit)

vertical_distance_levels <- 
  samples_vertical_distance_as_factor_fit %>%
  
  # only retain distace levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "1", "2", "3", "4"))
          
verticaldistancePlot_asFactor <-
ggplot(data=vertical_distance_levels, 
       aes(x = Beta, fill=Distance)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

verticaldistancePlot_asFactor
```

```{r Number of values above zero for vertical distance as factor}
vertical_distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for vertical distance condition}
ggarrange(vertical_distance_plot_main, 
  ggarrange(vertical_distance_plot_slope, verticaldistancePlot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

ggsave("walker-vertical-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```


## Distance horizontal condition

```{r}
horizontal_distance <- 
  reports %>%
  filter(SessionTag == "Addendum", Condition %in% c("Control", "Shift")) %>%
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0", "1", "2", "3", "4")) %>%
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting horizontal distance
ggplot(data=horizontal_distance,
       aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Shift", breaks = unique(horizontal_distance$ShiftAbs))
  
  
```

```{r fitting horizontal distance as a contiuous variable}
set.seed(723211)
horizontal_distance_fit <- brm(PcongruentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=horizontal_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r horizontal distance importance via loo}
horizontal_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=horizontal_distance)

horizontal_distance_fit <- add_criterion(horizontal_distance_fit, "loo", reloo=TRUE)
horizontal_distance_null_model <- add_criterion(horizontal_distance_null_model, "loo", reloo=TRUE)

loo_compare(horizontal_distance_null_model, horizontal_distance_fit, criterion = "loo", model_names = c("intercept", "Distance"))
loo_model_weights(horizontal_distance_null_model, horizontal_distance_fit, model_names = c("intercept", "Distance"))
```

```{r plot horizontal distance continous predictions}
horizontal_distance_fit_predictions <- predict(horizontal_distance_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

horizontal_distance_plot_main <-
  ggplot(data=horizontal_distance_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=horizontal_distance, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift [%]", breaks = unique(horizontal_distance$ShiftAbs)) +
  plot_theme

horizontal_distance_plot_main
```

```{r plotting horizontal distance slope}
horizontal_distance_plot_slope <- 
  posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  ggplot(aes(x=b_ShiftAbs)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Shift]))

horizontal_distance_plot_slope
```


```{r number if values above zero horizontal distance slope}
posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_ShiftAbs>0), 1))
```

## Horizontal Distance as factor
```{r fitting horizontal distance as factor}
set.seed(878929)
horizontal_distance_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=horizontal_distance,
                              prior=c(prior(normal(0,10), class="b")))
```

```{r plotting pariwise comparisons for individual levels of horizontal distance}
samples_horizontal_distance_as_factor_fit <- posterior_samples(horizontal_distance_as_factor_fit)

horizontal_distance_levels <- 
  samples_horizontal_distance_as_factor_fit %>%
  
  # only retain shift levels
  select(starts_with("b_Shift")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Shift", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Shift = str_remove_all(Shift, "b_ShiftAsFactor"),
         Shift = as.factor(Shift),
         Shift = fct_relevel(Shift, "0", "1", "2", "3", "4")) ## what goes wrong here with the negative values? also maybe a histogram is not the best choice for so many conditions
          
        
horizontal_distance_plot_asFactor <-
ggplot(data=horizontal_distance_levels, 
       aes(x = Beta, fill=Shift)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

horizontal_distance_plot_asFactor
```

```{r Number of values above zero for horizontal distance as factor}
horizontal_distance_levels %>%
  group_by(Shift) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for horizontal distance condition}
ggarrange(horizontal_distance_plot_main, 
  ggarrange(horizontal_distance_plot_slope, horizontal_distance_plot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

#ggsave("walker-horizontal-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```



## Ambiguity sphere condition
```{r}
sphere_ambiguity <- # how do i make it so -1 and -0.25 will be recognized as levels of ambiguiation?
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Sphere ambiguity"))%>%
  dplyr::mutate(SphereDisambiguationAbs = abs(SphereDisambiguation), 
                SphereDisambiguationAsFactor = as.factor(SphereDisambiguationAbs),
                SphereDisambiguationAsFactor = fct_relevel(SphereDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, SphereDisambiguationAbs, SphereDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              

# plotting SphereDisambiguation 
ggplot(data=sphere_ambiguity,
       aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent, color=Participant)) + 
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs))
```


```{r fitting sphere ambiguity as a contiuous variable}
set.seed(44279)
sphere_ambiguity_fit <- brm(PcongruentAdj ~ SphereDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=sphere_ambiguity,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```


```{r sphere ambiguation importance via loo}
sphere_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=sphere_ambiguity)

sphere_ambiguity_fit <- add_criterion(sphere_ambiguity_fit, "loo", reloo=TRUE)
sphere_ambiguity_null_model <- add_criterion(sphere_ambiguity_null_model, "loo", reloo=TRUE)

loo_compare(sphere_ambiguity_null_model, sphere_ambiguity_fit, criterion = "loo", model_names = c("intercept", "Sphere disambiguation"))
loo_model_weights(sphere_ambiguity_null_model, sphere_ambiguity_fit, model_names = c("intercept", "Sphere disambiguation"))
```

```{r plot sphere ambiguity continous predictions}
sphere_ambiguity_fit_predictions <- predict(sphere_ambiguity_fit,
                                             newdata = data.frame(SphereDisambiguation= seq( -2, 2, 0.25)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(SphereDisambiguation= seq( -2, 2, 0.25))

sphere_ambguity_plot_main <-
  ggplot(data=sphere_ambiguity_fit_predictions,
      aes(x = SphereDisambiguation, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=sphere_ambiguity, method="tukeyDense", width=2,
                aes(x=SphereDisambiguation, group=SphereDisambiguation, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Sphere Disambiguation [%]", breaks = unique(sphere_ambiguity$SphereDisambiguation)) +
  plot_theme

sphere_ambguity_plot_main
```

```{r plotting sphere ambiguity slope}
sphere_ambiguity_plot_slope <- 
  posterior_samples(sphere_ambiguity_fit)%>%
  select(b_SphereDisambiguation) %>%
  ggplot(aes(x=b_SphereDisambiguation)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[SphereDisambiguation]))

sphere_ambiguity_plot_slope
```


```{r number if values above zero sphere ambiguity slope}
posterior_samples(sphere_ambiguity_fit) %>%
  select(b_SphereDisambiguation) %>%
  summarise(PaboveZero = round(100 * mean(b_SphereDisambiguation>0), 1))
```

## Ambiguity sphere as factor
```{r fitting horizontal distance as factor}
set.seed(1495785)
sphere_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ SphereDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=sphere_ambiguity,
                                      prior=c(prior(normal(0,10), class="b")))
```
```{r plotting pairwise comparisons for the individual levels of sphere Ambiguity}
samples_sphere_ambiguity_as_factor_fit <- posterior_samples(sphere_ambiguity_as_factor_fit)

sphere_ambiguity_levels <- 
  samples_sphere_ambiguity_as_factor_fit%>%
  select(starts_with("b_SphereDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "SphereDisambiguation", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(SphereDisambiguation = str_remove_all(SphereDisambiguation, "b_SphereDisambiguationAsFactor"),
         SphereDisambiguation = as.factor(SphereDisambiguation),
         SphereDisambiguation = fct_relevel(SphereDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
sphere_ambiguity_plot_asFactor <-
ggplot(data=sphere_ambiguity_levels, 
       aes(x = Beta, fill=SphereDisambiguation)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

sphere_ambiguity_plot_asFactor
```

```{r computing values above 0 for sphere Ambiguity as factor}
sphere_ambiguity_levels %>%
  group_by(SphereDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r predicting and plotting sphere ambiguity}
## tried to copy what you did for gears ambiguity
sphere_ambiguity_fit_predictions <- predict(sphere_ambiguity_as_factor_fit,
                                     newdata = data.frame(SphereDisambiguation = levels(sphere_ambiguity$SphereDisambiguation)),
                                     summary = FALSE,
                                     re_formula = NA) %>%
  data.frame() %>%
  pivot_longer(everything(), names_to = "SphereDisambiguation", values_to = "Pcorotation") %>%
  mutate(SphereDisambiguation = factor(SphereDisambiguation, levels = sort(unique(SphereDisambiguation)), labels = levels(sphere_ambiguity$SphereDisambiguation)))
  

sphere_ambiguity_fit_moments <-
  sphere_ambiguity_fit_predictions %>%
  group_by(SphereDisambiguation) %>%
  summarise(meanP = mean(Pcorotation),
            medianP= median(Pcorotation))


sphere_ambiguity_plot_main <- 
  ggplot(data=sphere_ambiguity, aes(x=SphereDisambiguation, group=SphereDisambiguation, y=Pcorotation) )+
  geom_violin(data = sphere_ambiguity_fit_predictions, fill="gray64", color="white", draw_quantiles = c(0.5)) +
  # geom_boxplot(data = sphere_ambiguity_fit_predictions) +
  geom_quasirandom(width=0.15, method="tukeyDense")+
  plot_theme +
  theme(legend.position="none")
  

sphere_ambiguity_plot_main
```
```{r combining plots for sphere ambiguity}

# not really any succesfull plots to combine yet :(

```




## Ambiguity Walker condtiotn

```{r}

```


