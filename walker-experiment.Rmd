---
title: "Walker experiment"
author: "Lisa Koßmann, Alexander (Sasha) Pastukhov"
date: "31 1 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

extrafont::loadfonts(quiet = TRUE)
```

```{r libraries}
library(bayestestR)
library(betareg)
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpmisc)
library(ggpubr)
library(glue)
library(ggplot2)
library(grid)
library(patchwork)
library(readr)
library(reshape2)
library(stringr)
library(tibble)
library(tidyr)
```



```{r Tabula rasa}
rm(list=ls())
```


```{r Custom plotting theme}
plot_theme <- 
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
```

# Importing data
```{r Import}
read_walker_csv <- function(filename){
  read_csv(filename, 
           col_types=cols(
                .default = col_double(),
                Participant = col_character(),
                Session = col_character(),
                Block = col_double(),
                OnsetDelay = col_double(),
                Condition = col_character(),
                Percept = col_character(),
                Time = col_double()
              )) %>%
    mutate(SessionTag = ifelse("Shift" %in% names(.), "Addendum", "Main"))
}


reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*walker*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_walker_csv(.$filename[1])) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Session, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%

  # 4. Drop "end" Percept
  filter(Percept != "end")%>%
  
  #5. Renaming Percepts
  mutate(Percept=as.factor(Percept),
         Percept=fct_recode(Percept, "congruent"="up", "incongruent"="down"))
         

```


## Distance vertical condition
```{r}
vertical_distance <- 
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Distance"))%>%
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"0", "1", "2", "3", "4")) %>%
  
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting vertical distance
ggplot(data=vertical_distance,
       aes(x=Distance, group=Distance, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         xlab("Distance [%]")
```

```{r fitting vertical distance as a continous variable}
set.seed(45950)
vertical_distance_fit <- brm(PcongruentAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=vertical_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r vertical distance importance via loo}
vertical_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=vertical_distance)

vertical_distance_fit <- add_criterion(vertical_distance_fit, "loo", reloo=TRUE)
vertical_distance_null_model <- add_criterion(vertical_distance_null_model, "loo", reloo=TRUE)

#loo_compare(vertical_distance_null_model, vertical_distance_fit, criterion = "loo", model_names = c("intercept", "Distance"))
#loo_model_weights(vertical_distance_null_model, vertical_distance_fit, model_names = c("intercept", "Distance"))

vertical_distance_compare <- loo::loo_compare(list("Distance" = vertical_distance_fit$criteria$loo,
                                          "Intercept" = vertical_distance_null_model$criteria$loo))

vertical_distance_weight <- loo::loo_model_weights(list("Distance" = vertical_distance_fit$criteria$loo,
                                               "Intercept" = vertical_distance_null_model$criteria$loo))
```
```{r vertical distance model summary}
vertical_distance_summary <-
  fixef(vertical_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4),
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-vertical_distance_compare[2, 1], 1), "±", round(-vertical_distance_compare[2, 2], 2)),
         Weight = round(c(vertical_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r plot vertical distance continuous predictions}
#vertical_distance_fit_predictions <- predict(vertical_distance_fit,
   #                                          newdata = data.frame(Distance= seq(0, 4.2, length.out = 100)),
    #                                         probs = c(0.025, 0.25, 0.75, 0.975),
     #                                        re_formula = NA) %>%
#  data.frame()%>%
  #add_column(Distance= seq(0, 4.2, length.out = 100))
##
#vertical_distance_plot_main <-
#  ggplot(data=vertical_distance_fit_predictions, # lisa, come back here and figure out why you get an error message
    #  aes(x = Distance, y=Estimate)) + 
#  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
#  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
#geom_line() + 
 # geom_quasirandom(data=vertical_distance, method="tukeyDense", width=0.1,
 #               aes(x=Distance, group=Distance, y=Pcongruent)) + 
  #theme(legend.position = "none") + 
  #scale_x_continuous(name = "Distance [%]", breaks = unique(vertical_distance$Distance)) +
  #plot_theme

#vertical_distance_plot_main
```

```{r plotting vertical distance slope}
vertical_distance_plot_slope <- 
  posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  ggplot(aes(x=b_Distance)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Distance]))

vertical_distance_plot_slope
```

```{r number of values above zero vertical distance slope}
posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1))
```
## Vertical distance as factor
```{r fitting vertical distance as factor}
set.seed(96251)
vertical_distance_as_factor_fit <- brm(PcongruentAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(), 
                              data=vertical_distance,
                              prior=c(prior(normal(0,10), class="b")))
vertical_distance_comparison <-
  fixef(vertical_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r plotting pariwise comparisons for individual levels of vertical distance}
samples_vertical_distance_as_factor_fit <- posterior_samples(vertical_distance_as_factor_fit)

vertical_distance_levels <- 
  samples_vertical_distance_as_factor_fit %>%
  
  # only retain distace levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "1", "2", "3", "4"))
          
verticaldistancePlot_asFactor <-
ggplot(data=vertical_distance_levels, 
       aes(x = Beta, fill=Distance)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme +
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

verticaldistancePlot_asFactor
```

```{r Number of values above zero for vertical distance as factor}
vertical_distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```
```{r vertical distance continuous predictions}
vertical_distance_fit_predictions <- predict(vertical_distance_fit,
                                            newdata = data.frame(Distance= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
data.frame()%>%
  add_column(Distance= seq(0, 4.2, length.out = 100))

vertical_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(vertical_distance_summary))

vertical_distancePlot_main <-
  ggplot(data=vertical_distance_fit_predictions, 
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=vertical_distance, method="tukeyDense", width=0.2,
                aes(x=Distance, group=Distance, y=Pcongruent)) + 
  scale_x_continuous(name = "Distance [%]",breaks=unique(vertical_distance$Distance), #limits=c(-1,5),
                     sec.axis =  dup_axis(name=NULL, labels=vertical_distance_comparison$Label)) +
  scale_y_continuous(name="Pcongruent") +
  #scale_color_manual(values = c("#000000")) +
  plot_theme + 
  geom_table_npc(data=vertical_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text())

vertical_distancePlot_main

ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.png", units="cm", width=14, height=8)
ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```



```{r combining the plots for vertical distance condition}
ggarrange(vertical_distance_plot_main, 
  ggarrange(vertical_distance_plot_slope, verticaldistancePlot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

ggsave("walker-vertical-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```


## Distance horizontal condition

```{r}
horizontal_distance <- 
  reports %>%
  filter(SessionTag == "Addendum", Condition %in% c("Control", "Shift")) %>%
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0", "1", "2", "3", "4")) %>%
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting horizontal distance
ggplot(data=horizontal_distance,
       aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Shift", breaks = unique(horizontal_distance$ShiftAbs))
  
  
```

```{r fitting horizontal distance as a contiuous variable}
set.seed(723211)
horizontal_distance_fit <- brm(PcongruentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=horizontal_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r horizontal distance importance via loo}
horizontal_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=horizontal_distance)

horizontal_distance_fit <- add_criterion(horizontal_distance_fit, "loo", reloo=TRUE)
horizontal_distance_null_model <- add_criterion(horizontal_distance_null_model, "loo", reloo=TRUE)

horizontal_distance_compare <- loo::loo_compare(list("Distance" = horizontal_distance_fit$criteria$loo,
                                          "Intercept" = horizontal_distance_null_model$criteria$loo))

horizontal_distance_weight <- loo::loo_model_weights(list("Distance" = horizontal_distance_fit$criteria$loo,
                                               "Intercept" = horizontal_distance_null_model$criteria$loo))
```
```{r horizontal distance summary}
horizontal_distance_summary <-
  fixef(horizontal_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-horizontal_distance_compare[2, 1], 1), "±", round(-horizontal_distance_compare[2, 2], 2)),
         Weight = round(c(horizontal_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```



```{r plotting horizontal distance slope}
horizontal_distance_plot_slope <- 
  posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  ggplot(aes(x=b_ShiftAbs)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Shift]))

horizontal_distance_plot_slope
```


```{r number if values above zero horizontal distance slope}
posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_ShiftAbs>0), 1))
```


## Horizontal Distance as factor
```{r fitting horizontal distance as factor}
set.seed(878929)
horizontal_distance_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=horizontal_distance,
                              prior=c(prior(normal(0,10), class="b")))
horizontal_distance_comparison <-
  fixef(horizontal_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```


```{r plot horizontal distance continous predictions}
horizontal_distance_fit_predictions <- predict(horizontal_distance_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

horizontal_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(horizontal_distance_summary))

horizontal_distance_plot_main <-
  ggplot(data=horizontal_distance_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=horizontal_distance, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift [%]", breaks = unique(horizontal_distance$ShiftAbs),
                     sec.axis=dup_axis(name=NULL, labels=(horizontal_distance_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
  geom_table_npc(data=horizontal_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text())

horizontal_distance_plot_main


ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.png", units="cm", width=14, height=8)
ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```


```{r plotting pariwise comparisons for individual levels of horizontal distance}
samples_horizontal_distance_as_factor_fit <- posterior_samples(horizontal_distance_as_factor_fit)

horizontal_distance_levels <- 
  samples_horizontal_distance_as_factor_fit %>%
  
  # only retain shift levels
  select(starts_with("b_Shift")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Shift", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Shift = str_remove_all(Shift, "b_ShiftAsFactor"),
         Shift = as.factor(Shift),
         Shift = fct_relevel(Shift, "0", "1", "2", "3", "4")) ## what goes wrong here with the negative values? also maybe a histogram is not the best choice for so many conditions
          
        
horizontal_distance_plot_asFactor <-
ggplot(data=horizontal_distance_levels, 
       aes(x = Beta, fill=Shift)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

horizontal_distance_plot_asFactor
```

```{r Number of values above zero for horizontal distance as factor}
horizontal_distance_levels %>%
  group_by(Shift) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```



```{r combining the plots for horizontal distance condition}
ggarrange(horizontal_distance_plot_main, 
  ggarrange(horizontal_distance_plot_slope, horizontal_distance_plot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

#ggsave("walker-horizontal-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```



## Ambiguity sphere condition
```{r}
sphere_ambiguity <- # how do i make it so -1 and -0.25 will be recognized as levels of ambiguiation?
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Sphere ambiguity"))%>%
  dplyr::mutate(SphereDisambiguationAbs = abs(SphereDisambiguation), 
                SphereDisambiguationAsFactor = as.factor(SphereDisambiguationAbs),
                SphereDisambiguationAsFactor = fct_relevel(SphereDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, SphereDisambiguationAbs, SphereDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              

# plotting SphereDisambiguation 
ggplot(data=sphere_ambiguity,
       aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent, color=Participant)) + 
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs))
```


```{r fitting sphere ambiguity as a contiuous variable}
set.seed(44279)
sphere_ambiguity_fit <- brm(PcongruentAdj ~ SphereDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=sphere_ambiguity,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r sphere ambiguation importance via loo}
sphere_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=sphere_ambiguity)

sphere_ambiguity_fit <- add_criterion(sphere_ambiguity_fit, "loo", reloo=TRUE)
sphere_ambiguity_null_model <- add_criterion(sphere_ambiguity_null_model, "loo", reloo=TRUE)

sphere_ambiguity_compare <- loo::loo_compare(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                          "Intercept" = sphere_ambiguity_null_model$criteria$loo))

sphere_ambiguity_weight <- loo::loo_model_weights(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                               "Intercept" = sphere_ambiguity_null_model$criteria$loo))

#loo_compare(sphere_ambiguity_null_model, sphere_ambiguity_fit, criterion = "loo", model_names = c("intercept", "Sphere disambiguation"))
#loo_model_weights(sphere_ambiguity_null_model, sphere_ambiguity_fit, model_names = c("intercept", "Sphere disambiguation"))
```

```{r sphere ambiguity summary}
sphere_ambiguity_summary <-
  fixef(sphere_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-sphere_ambiguity_compare[2, 1], 1), "±",  round(-sphere_ambiguity_compare[2, 2], 2)),
         Weight = round(c(sphere_ambiguity_weight)["Sphere Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")

#sphere_ambiguity_summary<- 
 # subset(sphere_ambiguity_summary, Stat!="β" & Stat!="CI")

#melt(sphere_ambiguity_summary, varnames = names(dimnames(sphere_ambiguity_summary)))

```

## Ambiguity sphere as factor
```{r fitting sphere ambiguity as factor}
set.seed(1495785)
sphere_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ SphereDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=sphere_ambiguity,
                                      prior=c(prior(normal(0,10), class="b")))

sphere_ambiguity_comparison <-
  fixef(sphere_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)

```

```{r plot sphere ambiguity continous predictions  MAIN PLOT}
sphere_ambiguity_fit_predictions <- predict(sphere_ambiguity_fit,
                                             newdata = data.frame(SphereDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(SphereDisambiguationAbs= seq( 0, 1, length.out= 100))

#sphere_ambiguity_summary %>% 
 #  pivot_wider(names_from = Stat, values_from = Value) 

sphere_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(sphere_ambiguity_summary))


#sphere_ambiguity_plot_main <-
 # ggplot(data=sphere_ambiguity_fit_predictions, 
 #     aes(x = SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Estimate)) + 
 # geom_line() +
 # geom_hline(yintercept = 0.5, color="white", size= 1) +
 # geom_violin(data = sphere_ambiguity_fit_predictions, aes(x=SphereDisambiguationAbs), 
 #             fill="gray64", color="white", draw_quantiles = c(0.5)) +
 # geom_quasirandom(data=sphere_ambiguity, method="tukeyDense", width=0.1,
 ##               aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent)) +
 # theme(legend.position = "none")+ 
 # scale_x_continuous(name="Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs),
    #                                sec.axis =  dup_axis(name = NULL, labels=(sphere_ambiguity_comparison$Label))) +
#scale_y_continuous(name="Pcongruent") +
  #scale_color_manual(values = c()) +
 # plot_theme +
 # geom_table_npc(data=sphere_ambiguity_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
 # theme(legend.position = "none",
   #     axis.text.x.top = element_text())
  
#sphere_ambiguity_plot_main

#ggsave(ambiguityPlot_main, filename = "gears-ambiguity.png", units="cm", width=14, height=8)
#ggsave(ambiguityPlot_main, filename = "gears-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)

sphere_ambiguity_plot_main <-
  ggplot(data=sphere_ambiguity_fit_predictions,
     aes(x = SphereDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=sphere_ambiguity, method="tukeyDense", width= 0.1,
              aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(sphere_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
  labs(subtitle=glue("β = {sphere_ambiguity_summary$Value[1]}, CI={sphere_ambiguity_summary$Value[2]}, ΔELPD={sphere_ambiguity_summary$Value[3]} , Weight={sphere_ambiguity_summary$Value[4]}"))+
    theme(legend.position = "none",
        axis.text.x.top = element_text())
sphere_ambiguity_plot_main

ggsave(sphere_ambiguity_plot_main, filename = "sphere_ambiguity.png", units="cm", width=14, height=8)
ggsave(sphere_ambiguity_plot_main, filename = "sphere-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```
```{r}

```


```{r plotting sphere ambiguity slope}
sphere_ambiguity_plot_slope <- 
  posterior_samples(sphere_ambiguity_fit)%>%
  select(b_SphereDisambiguationAbs) %>%
  ggplot(aes(x=b_SphereDisambiguationAbs)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[SphereDisambiguation]))

sphere_ambiguity_plot_slope
```


```{r number if values above zero sphere ambiguity slope}
posterior_samples(sphere_ambiguity_fit) %>%
  select(b_SphereDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_SphereDisambiguationAbs>0), 1))
```



```{r plotting pairwise comparisons for the individual levels of sphere Ambiguity}
samples_sphere_ambiguity_as_factor_fit <- posterior_samples(sphere_ambiguity_as_factor_fit)

sphere_ambiguity_levels <- 
  samples_sphere_ambiguity_as_factor_fit%>%
  select(starts_with("b_SphereDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "SphereDisambiguation", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(SphereDisambiguation = str_remove_all(SphereDisambiguation, "b_SphereDisambiguationAsFactor"),
         SphereDisambiguation = as.factor(SphereDisambiguation),
         SphereDisambiguation = fct_relevel(SphereDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
sphere_ambiguity_plot_asFactor <-
ggplot(data=sphere_ambiguity_levels, 
       aes(x = Beta, fill=SphereDisambiguation)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

sphere_ambiguity_plot_asFactor
# what happened to ambiguity of 0
```

```{r computing values above 0 for sphere Ambiguity as factor}
sphere_ambiguity_levels %>%
  group_by(SphereDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for sphere ambiguity condition}
ggarrange(sphere_ambguity_plot_main, 
  ggarrange(sphere_ambiguity_plot_slope, sphere_ambiguity_plot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

ggsave("walker-sphere-ambiguity", width = 12, height=8, units="cm", device=cairo_pdf)

```




## Ambiguity Walker condtion

```{r preprocessing}
walker_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Walker ambiguity"))%>%

  dplyr::mutate(WalkerDisambiguationAbs = abs(WalkerDisambiguation), 
                WalkerDisambiguationAsFactor = as.factor(WalkerDisambiguationAbs),
                WalkerDisambiguationAsFactor = fct_relevel(WalkerDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, WalkerDisambiguationAbs, WalkerDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              

# plotting WalkerDisambiguation 
ggplot(data=walker_ambiguity,
       aes(x=WalkerDisambiguationAbs, group=WalkerDisambiguationAbs, y=Pcongruent, color=Participant)) + 
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Walker Disambiguation", breaks = unique(walker_ambiguity$WalkerDisambiguationAbs))
```

```{r fitting walker ambiguity as a contiuous variable}
set.seed(44279)
walker_ambiguity_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=walker_ambiguity,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r walker ambiguation importance via loo}
walker_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=walker_ambiguity)

walker_ambiguity_fit <- add_criterion(walker_ambiguity_fit, "loo", reloo=TRUE)
walker_ambiguity_null_model <- add_criterion(walker_ambiguity_null_model, "loo", reloo=TRUE)

walker_ambiguity_compare <- loo::loo_compare(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                          "Intercept" = walker_ambiguity_null_model$criteria$loo))

walker_ambiguity_weight <- loo::loo_model_weights(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                               "Intercept" = walker_ambiguity_null_model$criteria$loo))

#loo_compare(walker_ambiguity_null_model, walker_ambiguity_fit, criterion = "loo", model_names = c("intercept", "Walker disambiguation"))
#loo_model_weights(walker_ambiguity_null_model, walker_ambiguity_fit, model_names = c("intercept", "Walker disambiguation"))
```


```{r walker ambiguity summary}
walker_ambiguity_summary <-
  fixef(walker_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-walker_ambiguity_compare[2, 1], 1), "±", round(-walker_ambiguity_compare[2, 2], 2)),
         Weight = round(c(walker_ambiguity_weight)["Walker Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
#walker_ambiguity_summary<- 
 # subset(walker_ambiguity_summary, Stat!="β" & Stat!="CI")
```


```{r plot walker ambiguity continous predictions}
#walker_ambiguity_fit_predictions <- predict(walker_ambiguity_fit,
  ##                                           newdata = data.frame(WalkerDisambiguationAbs= seq(0, 1, length.out = 100)),
#                                             probs = c(0.025, 0.25, 0.75, 0.975),
#                                             re_formula = NA) %>%
 ## data.frame()%>%
 # add_column(WalkerDisambiguationAbs= seq( 0, 1, length.out= 100))

#walker_ambguity_plot_main <-
#  ggplot(data=walker_ambiguity_fit_predictions,
#      aes(x = WalkerDisambiguationAbs, y=Estimate)) + 
 # geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 # geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 # geom_line() + 
 # geom_quasirandom(data=walker_ambiguity, method="tukeyDense", width= 0.2,
 #               aes(x=WalkerDisambiguationAbs, group=WalkerDisambiguationAbs, y=Pcongruent)) + 
  #theme(legend.position = "none") + 
  #scale_x_continuous(name = "Walker Disambiguation [%]", breaks = unique(walker_ambiguity$WalkerDisambiguationAbs)) +
 # plot_theme

#walker_ambguity_plot_main
```

```{r plotting walker ambiguity slope}
walker_ambiguity_plot_slope <- 
  posterior_samples(walker_ambiguity_fit)%>%
  select(b_WalkerDisambiguationAbs) %>%
  ggplot(aes(x=b_WalkerDisambiguationAbs)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[WalkerDisambiguation]))

walker_ambiguity_plot_slope
```

```{r number of values above zero walker ambiguity slope}
posterior_samples(walker_ambiguity_fit) %>%
  select(b_WalkerDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_WalkerDisambiguationAbs>0), 1))
```

## Walker ambiguity as factor

```{r fitting walker ambiguity as factor}
set.seed(582961)
walker_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=walker_ambiguity,
                                      cores=future::availableCores(),
                                      prior=c(prior(normal(0,10), class="b")))
walker_ambiguity_comparison <-
  fixef(walker_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r predictions and MAIN PLOT}
walker_ambiguity_fit_predictions <- predict(walker_ambiguity_fit,
                                             newdata = data.frame(WalkerDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(WalkerDisambiguationAbs= seq( 0, 1, length.out= 100))

walker_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(walker_ambiguity_summary))

walker_ambiguity_plot_main <-
  ggplot(data=walker_ambiguity_fit_predictions,
     aes(x = WalkerDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=walker_ambiguity, method="tukeyDense", width= 0.1,
              aes(x=WalkerDisambiguationAbs, group=WalkerDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Walker Disambiguation", breaks = unique(walker_ambiguity$WalkerDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(walker_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
  geom_table_npc(data=walker_ambiguity_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text())
walker_ambiguity_plot_main

ggsave(walker_ambiguity_plot_main, filename = "walker_ambiguity.png", units="cm", width=14, height=8)
ggsave(walker_ambiguity_plot_main, filename = "walker-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```


```{r plotting pairwise comparisons for the individual levels of walker Ambiguity}
samples_walker_ambiguity_as_factor_fit <- posterior_samples(walker_ambiguity_as_factor_fit)

walker_ambiguity_levels <- 
  samples_walker_ambiguity_as_factor_fit%>%
  select(starts_with("b_WalkerDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "WalkerDisambiguation", values_to = "Beta") %>%

  # turn walker name into a factor
  mutate(WalkerDisambiguation = str_remove_all(WalkerDisambiguation, "b_WalkerDisambiguationAsFactor"),
        WalkerDisambiguation = as.factor(WalkerDisambiguation),
         WalkerDisambiguation = fct_relevel(WalkerDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
walker_ambiguity_plot_asFactor <-
ggplot(data=walker_ambiguity_levels, 
       aes(x = Beta, fill=WalkerDisambiguation)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

walker_ambiguity_plot_asFactor
```


```{r computing values above 0 for walker Ambiguity as factor}
walker_ambiguity_levels %>%
  group_by(WalkerDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for walker ambiguity condition}
ggarrange(walker_ambguity_plot_main, 
  ggarrange(walker_ambiguity_plot_slope, walker_ambiguity_plot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

ggsave("walker-walker-ambiguity", width = 12, height=8, units="cm", device=cairo_pdf)
```

