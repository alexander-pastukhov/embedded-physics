---
title: "Walker experiment"
author: "Lisa Koßmann, Alexander (Sasha) Pastukhov"
date: "31 1 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

extrafont::loadfonts(quiet = TRUE)
```

```{r libraries}
library(bayestestR)
library(betareg)
library(boot)
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpmisc)
library(ggpubr)
library(glue)
library(ggplot2)
library(grid)
library(patchwork)
library(readr)
library(reshape2)
library(stringr)
library(tibble)
library(tidyr)
```



```{r Tabula rasa}
rm(list=ls())
```

## Utilities
```{r Custom plotting theme}
plot_theme <- function()
{
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
}
```

### Computing comparisons between the two models
```{r compute BF}
compute_BF <- function(full_model, reduced_model){
  BF <- brms::bayes_factor(full_model, reduced_model, silent = TRUE)
  sprintf('BF=%.2g', BF$bf)
}
```

```{r compute dELPD}
compute_dELPD <- function(full_model, intercept_model){
  dLOO <-   
    loo::loo_compare(list("Term" = full_model$criteria$loo,
                          "Intercept" = intercept_model$criteria$loo)) %>%
    data.frame() %>%
    rownames_to_column("Coefficient") %>%
    
    # invert difference, so it is positive if full model is better (and negative if it worse than intercept only)
    mutate(elpd_diff = ifelse(Coefficient == "Intercept", -elpd_diff, elpd_diff)) %>%
    slice(2)
    
  sprintf("ΔELPD=%.1f±%.2f", dLOO$elpd_diff[1], dLOO$se_diff[1])
}
```

```{r compute full model weight}
compute_full_model_weight <- function(full_mode, intercepts_model){
  sfull_model_weight <- 
    loo::loo_model_weights(list("Term" = full_mode$criteria$loo,
                                "Intercept" = intercepts_model$criteria$loo))["Term"]
  
  sprintf("W=%.2f", full_model_weight)
}
```

```{r compare two models}
compare_models <- function(full_model, intercept_model){
  BF <- compute_BF(full_model, intercept_model)
  dELPD <- compute_dELPD(full_model, intercept_model)
  Weight <- compute_full_model_weight(full_model, intercept_model)

  stringr::str_c(dELPD, Weight, BF, sep=', ')
}
```

# Importing data
```{r Import}
read_walker_csv <- function(filename){
  read_csv(filename, 
           col_types=cols(
                .default = col_double(),
                Participant = col_character(),
                Session = col_character(),
                Block = col_double(),
                OnsetDelay = col_double(),
                Condition = col_character(),
                Percept = col_character(),
                Time = col_double()
              )) %>%
    mutate(SessionTag = case_when(stringr::str_detect(filename, "addendumer") ~ "Addendumer",
                                  "Shift" %in% names(.) ~ "Addendum", 
                                  TRUE ~ "Main"))
}

reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*walker*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  group_by(filename) %>% #rowwise() %>%
  do(read_walker_csv(.$filename[1])) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Session, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%

  # 4. Drop "end" Percept
  filter(Percept != "end")%>%
  
  #5. Renaming Percepts
  mutate(RawPercept = Percept, 
         Percept=as.factor(Percept),
         Percept=fct_recode(Percept, "congruent"="up", "incongruent"="down"))
```


## Distance vertical condition
```{r}
vertical_distance <- 
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Distance"))%>%
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"0", "1", "2", "3", "4")) %>%
  
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)
```

```{r fitting vertical distance as a continous variable}
set.seed(45950)
vertical_distance_fit <- brm(PcongruentAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=vertical_distance,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r vertical distance importance via loo}
vertical_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=vertical_distance)

BF_vertical_distance<-brms::bayes_factor(vertical_distance_fit, vertical_distance_null_model)

vertical_distance_fit <- add_criterion(vertical_distance_fit, "loo", reloo=TRUE)
vertical_distance_null_model <- add_criterion(vertical_distance_null_model, "loo", reloo=TRUE)

vertical_distance_compare <- loo::loo_compare(list("Distance" = vertical_distance_fit$criteria$loo,
                                          "Intercept" = vertical_distance_null_model$criteria$loo))

vertical_distance_weight <- loo::loo_model_weights(list("Distance" = vertical_distance_fit$criteria$loo,
                                               "Intercept" = vertical_distance_null_model$criteria$loo))

BF_vertical_distance
```
```{r rounding bayes factor vertical distance}
BF_vertical_distance_rounded <- round(BF_vertical_distance$bf,digits=2)
BF_vertical_distance_rounded <- sprintf('%.2g', BF_vertical_distance$bf)
BF_vertical_distance_rounded
```


```{r vertical distance model summary}
vertical_distance_summary <-
  fixef(vertical_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4),
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-vertical_distance_compare[2, 1], 1), "±", round(-vertical_distance_compare[2, 2], 2)),
         Weight = round(c(vertical_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r number of values above zero vertical distance slope}
posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1))
```
## Vertical distance as factor
```{r fitting vertical distance as factor}
set.seed(96251)
vertical_distance_as_factor_fit <- brm(PcongruentAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(), 
                              data=vertical_distance,
                              cores=future::availableCores(),
                              prior=c(prior(normal(0,10), class="b")))
vertical_distance_comparison <-
  fixef(vertical_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r plotting pariwise comparisons for individual levels of vertical distance}
samples_vertical_distance_as_factor_fit <- posterior_samples(vertical_distance_as_factor_fit)

vertical_distance_levels <- 
  samples_vertical_distance_as_factor_fit %>%
  
  # only retain distace levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "1", "2", "3", "4"))
          
```

```{r Number of values above zero for vertical distance as factor}
vertical_distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```
```{r vertical distance continuous predictions MAIN PLOT}
vertical_distance_fit_predictions <- predict(vertical_distance_fit,
                                            newdata = data.frame(Distance= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
data.frame()%>%
  add_column(Distance= seq(0, 4.2, length.out = 100))

vertical_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(vertical_distance_summary))

vertical_distancePlot_main <-
  ggplot(data=vertical_distance_fit_predictions, 
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=vertical_distance, method="tukeyDense", width=0.1,
                aes(x=Distance, group=Distance, y=Pcongruent)) + 
  scale_x_continuous(name = "Absolute Vertical Distance (degrees)",breaks=unique(vertical_distance$Distance), #limits=c(-1,5),
                     sec.axis =  dup_axis(name=NULL, labels=vertical_distance_comparison$Label)) +
  scale_y_continuous(name="Pcongruent", limits= c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  #scale_color_manual(values = c("#000000")) +
  plot_theme() + 
   labs(subtitle=glue("β={vertical_distance_summary$Value[1]}, CI={vertical_distance_summary$Value[2]}, ΔELPD={vertical_distance_summary$Value[3]} , W={vertical_distance_summary$Value[4]}, BF={BF_vertical_distance_rounded}"))+
  #geom_table_npc(data=vertical_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) + 
  theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))

vertical_distancePlot_main

ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.png", units="cm", width=14, height=8)
ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

## Distance horizontal condition

```{r}
horizontal_distance <- 
  reports %>%
  filter(SessionTag == "Addendum", Condition %in% c("Control", "Shift")) %>%
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0", "1", "2", "3", "4")) %>%
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)


```

```{r fitting horizontal distance as a contiuous variable}
set.seed(723211)
horizontal_distance_fit <- brm(PcongruentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=horizontal_distance,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r horizontal distance importance via loo}
horizontal_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=horizontal_distance)

BF_horizontal_distance = brms::bayes_factor(horizontal_distance_fit, horizontal_distance_null_model)


horizontal_distance_fit <- add_criterion(horizontal_distance_fit, "loo", reloo=TRUE)
horizontal_distance_null_model <- add_criterion(horizontal_distance_null_model, "loo", reloo=TRUE)

horizontal_distance_compare <- loo::loo_compare(list("Distance" = horizontal_distance_fit$criteria$loo,
                                          "Intercept" = horizontal_distance_null_model$criteria$loo))

horizontal_distance_weight <- loo::loo_model_weights(list("Distance" = horizontal_distance_fit$criteria$loo,
                                               "Intercept" = horizontal_distance_null_model$criteria$loo))
BF_horizontal_distance
```
```{r rounding bayes factor horizontal distabnce}
BF_horizontal_distance_rounded <- round(BF_horizontal_distance$bf,digits=2)
BF_horizontal_distance_rounded <- sprintf('%.2g', BF_horizontal_distance$bf)
BF_horizontal_distance_rounded
```


```{r horizontal distance summary}
horizontal_distance_summary <-
  fixef(horizontal_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-horizontal_distance_compare[2, 1], 1), "±", round(-horizontal_distance_compare[2, 2], 2)),
         Weight = round(c(horizontal_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r number if values above zero horizontal distance slope}
posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_ShiftAbs>0), 1))
```


## Horizontal Distance as factor
```{r fitting horizontal distance as factor}
set.seed(878929)
horizontal_distance_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=horizontal_distance,
                              prior=c(prior(normal(0,10), class="b")))
horizontal_distance_comparison <-
  fixef(horizontal_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```


```{r plot horizontal distance continous predictions MAIN PLOT}
horizontal_distance_fit_predictions <- predict(horizontal_distance_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

horizontal_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(horizontal_distance_summary))

horizontal_distance_plot_main <-
  ggplot(data=horizontal_distance_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=horizontal_distance, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Absolute Horizontal Distance (degrees)", breaks = unique(horizontal_distance$ShiftAbs),
                     sec.axis=dup_axis(name=NULL, labels=(horizontal_distance_comparison$Label))) +
  scale_y_continuous(name="Pcongruent", limits= c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  plot_theme() +
   labs(subtitle=glue("β = {horizontal_distance_summary$Value[1]}, CI={horizontal_distance_summary$Value[2]}, ΔELPD={horizontal_distance_summary$Value[3]} , W={horizontal_distance_summary$Value[4]}, BF={BF_horizontal_distance_rounded}"))+
  #geom_table_npc(data=horizontal_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))

horizontal_distance_plot_main


ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.png", units="cm", width=14, height=8)
ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```


```{r plotting pariwise comparisons for individual levels of horizontal distance}
samples_horizontal_distance_as_factor_fit <- posterior_samples(horizontal_distance_as_factor_fit)

horizontal_distance_levels <- 
  samples_horizontal_distance_as_factor_fit %>%
  
  # only retain shift levels
  select(starts_with("b_Shift")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Shift", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Shift = str_remove_all(Shift, "b_ShiftAsFactor"),
         Shift = as.factor(Shift),
         Shift = fct_relevel(Shift, "0", "1", "2", "3", "4"))
```

```{r Number of values above zero for horizontal distance as factor}
horizontal_distance_levels %>%
  group_by(Shift) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```



## Ambiguity sphere condition
```{r}
sphere_ambiguity <- # how do i make it so -1 and -0.25 will be recognized as levels of ambiguiation?
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Sphere ambiguity"))%>%
  dplyr::mutate(SphereDisambiguationAbs = abs(SphereDisambiguation), 
                SphereDisambiguationAsFactor = as.factor(SphereDisambiguationAbs),
                SphereDisambiguationAsFactor = fct_relevel(SphereDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, SphereDisambiguationAbs, SphereDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              
```


```{r fitting sphere ambiguity as a contiuous variable}
set.seed(44279)
sphere_ambiguity_fit <- brm(PcongruentAdj ~ SphereDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=sphere_ambiguity,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r sphere ambiguation importance via loo}
sphere_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=sphere_ambiguity)

BF_sphere_ambiguity = brms::bayes_factor(sphere_ambiguity_fit, sphere_ambiguity_null_model)


sphere_ambiguity_fit <- add_criterion(sphere_ambiguity_fit, "loo", reloo=TRUE)
sphere_ambiguity_null_model <- add_criterion(sphere_ambiguity_null_model, "loo", reloo=TRUE)

sphere_ambiguity_compare <- loo::loo_compare(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                          "Intercept" = sphere_ambiguity_null_model$criteria$loo))

sphere_ambiguity_weight <- loo::loo_model_weights(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                               "Intercept" = sphere_ambiguity_null_model$criteria$loo))

```
```{r rounding bayes factor sphere ambiguity}
BF_sphere_ambiguity_rounded <- round(BF_sphere_ambiguity$bf,digits=2)
BF_sphere_ambiguity_rounded <- sprintf('%.2g', BF_sphere_ambiguity$bf)
BF_sphere_ambiguity_rounded


```


```{r sphere ambiguity summary}
sphere_ambiguity_summary <-
  fixef(sphere_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-sphere_ambiguity_compare[2, 1], 1), "±",  round(-sphere_ambiguity_compare[2, 2], 2)),
         Weight = round(c(sphere_ambiguity_weight)["Sphere Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")

#sphere_ambiguity_summary<- 
 # subset(sphere_ambiguity_summary, Stat!="β" & Stat!="CI")

#melt(sphere_ambiguity_summary, varnames = names(dimnames(sphere_ambiguity_summary)))

```

## Ambiguity sphere as factor
```{r fitting sphere ambiguity as factor}
set.seed(1495785)
sphere_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ SphereDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=sphere_ambiguity,
                                      cores=future::availableCores(),
                                      prior=c(prior(normal(0,10), class="b")))

sphere_ambiguity_comparison <-
  fixef(sphere_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)

```

```{r plot sphere ambiguity continous predictions  MAIN PLOT}
sphere_ambiguity_fit_predictions <- predict(sphere_ambiguity_fit,
                                             newdata = data.frame(SphereDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(SphereDisambiguationAbs= seq( 0, 1, length.out= 100))

#sphere_ambiguity_summary %>% 
 #  pivot_wider(names_from = Stat, values_from = Value) 

sphere_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(sphere_ambiguity_summary))



sphere_ambiguity_plot_main <-
  ggplot(data=sphere_ambiguity_fit_predictions,
     aes(x = SphereDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=sphere_ambiguity, method="tukeyDense", width= 0.07,
              aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Sphere, Stereo Cues Disambiguation Strength (degrees)", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(sphere_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent", limits= c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  plot_theme() +
  labs(subtitle=glue("β={sphere_ambiguity_summary$Value[1]}, CI={sphere_ambiguity_summary$Value[2]}, ΔELPD={sphere_ambiguity_summary$Value[3]} , W={sphere_ambiguity_summary$Value[4]}, BF={BF_sphere_ambiguity_rounded}"))+
    theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))
sphere_ambiguity_plot_main

ggsave(sphere_ambiguity_plot_main, filename = "sphere_ambiguity.png", units="cm", width=14, height=8)
ggsave(sphere_ambiguity_plot_main, filename = "sphere-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```




```{r number if values above zero sphere ambiguity slope}
posterior_samples(sphere_ambiguity_fit) %>%
  select(b_SphereDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_SphereDisambiguationAbs>0), 1))
```



```{r plotting pairwise comparisons for the individual levels of sphere Ambiguity}
samples_sphere_ambiguity_as_factor_fit <- posterior_samples(sphere_ambiguity_as_factor_fit)

sphere_ambiguity_levels <- 
  samples_sphere_ambiguity_as_factor_fit%>%
  select(starts_with("b_SphereDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "SphereDisambiguation", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(SphereDisambiguation = str_remove_all(SphereDisambiguation, "b_SphereDisambiguationAsFactor"),
         SphereDisambiguation = as.factor(SphereDisambiguation),
         SphereDisambiguation = fct_relevel(SphereDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
```

```{r computing values above 0 for sphere Ambiguity as factor}
sphere_ambiguity_levels %>%
  group_by(SphereDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```





## Ambiguity Walker condtion

```{r preprocessing}
walker_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Walker ambiguity"))%>%

  dplyr::mutate(WalkerDisambiguationAbs = abs(WalkerDisambiguation), 
                WalkerDisambiguationAsFactor = as.factor(WalkerDisambiguationAbs),
                WalkerDisambiguationAsFactor = fct_relevel(WalkerDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, WalkerDisambiguationAbs, WalkerDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              


```

```{r fitting walker ambiguity as a contiuous variable}
set.seed(44279)
walker_ambiguity_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=walker_ambiguity,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r walker ambiguation importance via loo}
walker_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=walker_ambiguity)

BF_walker_ambiguity = brms::bayes_factor(walker_ambiguity_fit, walker_ambiguity_null_model)


walker_ambiguity_fit <- add_criterion(walker_ambiguity_fit, "loo", reloo=TRUE)
walker_ambiguity_null_model <- add_criterion(walker_ambiguity_null_model, "loo", reloo=TRUE)

walker_ambiguity_compare <- loo::loo_compare(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                          "Intercept" = walker_ambiguity_null_model$criteria$loo))

walker_ambiguity_weight <- loo::loo_model_weights(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                               "Intercept" = walker_ambiguity_null_model$criteria$loo))

```
```{r rounding bayes factor walker ambiguity}
BF_walker_ambiguity_rounded <- round(BF_walker_ambiguity$bf,digits=2)
BF_walker_ambiguity_rounded <- sprintf('%.2g', BF_walker_ambiguity$bf)
BF_walker_ambiguity_rounded
```


```{r walker ambiguity summary}
walker_ambiguity_summary <-
  fixef(walker_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-walker_ambiguity_compare[2, 1], 1), "±", round(-walker_ambiguity_compare[2, 2], 2)),
         Weight = round(c(walker_ambiguity_weight)["Walker Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
#walker_ambiguity_summary<- 
 # subset(walker_ambiguity_summary, Stat!="β" & Stat!="CI")
```


```{r number of values above zero walker ambiguity slope}
posterior_samples(walker_ambiguity_fit) %>%
  select(b_WalkerDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_WalkerDisambiguationAbs>0), 1))
```

## Walker ambiguity as factor

```{r fitting walker ambiguity as factor}
set.seed(582961)
walker_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=walker_ambiguity,
                                      cores=future::availableCores(),
                                      prior=c(prior(normal(0,10), class="b")))
walker_ambiguity_comparison <-
  fixef(walker_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r predictions and MAIN PLOT}
walker_ambiguity_fit_predictions <- predict(walker_ambiguity_fit,
                                             newdata = data.frame(WalkerDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(WalkerDisambiguationAbs= seq( 0, 1, length.out= 100))

walker_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(walker_ambiguity_summary))

walker_ambiguity_plot_main <-
  ggplot(data=walker_ambiguity_fit_predictions,
     aes(x = WalkerDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=walker_ambiguity, method="tukeyDense", width= 0.07,
              aes(x=WalkerDisambiguationAbs, group=WalkerDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Walker, Stereo Cues Disambiguation Strength (degrees)", breaks = unique(walker_ambiguity$WalkerDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(walker_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent", limits= c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  plot_theme() +
  labs(subtitle=glue("β={walker_ambiguity_summary$Value[1]}, CI={walker_ambiguity_summary$Value[2]}, ΔELPD={walker_ambiguity_summary$Value[3]} , W={walker_ambiguity_summary$Value[4]}, BF={BF_walker_ambiguity_rounded}"))+
  #geom_table_npc(data=walker_ambiguity_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))
walker_ambiguity_plot_main

ggsave(walker_ambiguity_plot_main, filename = "walker_ambiguity.png", units="cm", width=14, height=8)
ggsave(walker_ambiguity_plot_main, filename = "walker-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

```{r}
vertical_distancePlot_main /
horizontal_distance_plot_main /
sphere_ambiguity_plot_main /
walker_ambiguity_plot_main + 
  plot_annotation(tag_levels= "A")

ggsave('figure-03-walker-both.pdf', width=14, height=24, units="cm", device=cairo_pdf)
ggsave('figure-03-walker-both.png', width=14, height=24, units="cm")
```


```{r plotting pairwise comparisons for the individual levels of walker Ambiguity}
samples_walker_ambiguity_as_factor_fit <- posterior_samples(walker_ambiguity_as_factor_fit)

walker_ambiguity_levels <- 
  samples_walker_ambiguity_as_factor_fit%>%
  select(starts_with("b_WalkerDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "WalkerDisambiguation", values_to = "Beta") %>%

  # turn walker name into a factor
  mutate(WalkerDisambiguation = str_remove_all(WalkerDisambiguation, "b_WalkerDisambiguationAsFactor"),
        WalkerDisambiguation = as.factor(WalkerDisambiguation),
         WalkerDisambiguation = fct_relevel(WalkerDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
```


```{r computing values above 0 for walker Ambiguity as factor}
walker_ambiguity_levels %>%
  group_by(WalkerDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```



## Single object report condition walker

```{r}
SOR_walker<- 
  reports %>%
  filter(SessionTag=="Addendumer", Condition %in% c("Walker")) %>%
  
  # adding information on whether walker's motion was congruent with the bias sphere rotation
  mutate(IsCongruent = (SphereBias == -1 & RawPercept == "up") | (SphereBias == 1 & RawPercept == "down")) %>%
  
  # computing absolute shift
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0","2","4")) %>%

  ## ----------- SASHA SAYS -----------
  ## 
  ## You need to change the next bit to compute the proportion of duration
  ## when walker motion was congruent using IsCongruent logical variable.
  ## 
  ## ----------- SASHA SAYS -----------

  # computing Pcongurent for each participant and Shift seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[IsCongruent=="TRUE"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)
  
  #filter(Participant == "BBF1996WLNO", "CSS1997WRNO", "DTS1997MRNO","GNF1998WRNO", "ILM1998WRNO", "JBT1998WRNO", "KEB1999WRNO", "SKB1999WRNO", "SKM2000WLNO", "USB1997WRNO"
   
```

```{r fitting SOR walker as a contiuous variable}
set.seed(11914)
SOR_walker_fit <- brm(PcongruentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=SOR_walker,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r SOR walker importance via loo}
SOR_walker_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=SOR_walker)

BF_SOR_walker = brms::bayes_factor(SOR_walker_fit, SOR_walker_null_model)


SOR_walker_fit <- add_criterion(SOR_walker_fit, "loo", reloo=TRUE)
SOR_walker_null_model <- add_criterion(SOR_walker_null_model, "loo", reloo=TRUE)

SOR_walker_compare <- loo::loo_compare(list("Distance" = SOR_walker_fit$criteria$loo,
                                          "Intercept" = SOR_walker_null_model$criteria$loo))

SOR_walker_weight <- loo::loo_model_weights(list("Distance" = SOR_walker_fit$criteria$loo,
                                               "Intercept" = SOR_walker_null_model$criteria$loo))
BF_SOR_walker
```

```{r rounding BF SOR walker}
BF_SOR_walker_rounded <- round(BF_SOR_walker$bf,digits=2)
BF_SOR_walker_rounded

```

```{r SOR walker summary}
SOR_walker_summary <-
  fixef(SOR_walker_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-SOR_walker_compare[2, 1], 1), "±", round(-SOR_walker_compare[2, 2], 2)),
         Weight = round(c(SOR_walker_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r fitting SOR walker as factor}
set.seed(878929)
SOR_walker_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=SOR_walker,
                              prior=c(prior(normal(0,10), class="b")))


```
```{r SOR walker comparison}
SOR_walker_comparison <-
  fixef(SOR_walker_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```


```{r plot SOR walker continous predictions MAIN PLOT}
SOR_walker_fit_predictions <- predict(SOR_walker_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

SOR_walker_inset <-
  tibble(x=0.01, y=0.92, tb=list(SOR_walker_summary))

SOR_walker_plot_main <-
  ggplot(data=SOR_walker_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=SOR_walker, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift (degrees)", breaks = unique(SOR_walker$ShiftAbs),
                     sec.axis=dup_axis(name=NULL, labels=(SOR_walker_comparison$Label))) +
  scale_y_continuous(name="Pcongruent", limits= c(0, 1), breaks = c(0, 0.25, 0.5, 0.75, 1)) +
  plot_theme() +
   labs(subtitle=glue("β={SOR_walker_summary$Value[1]}, CI={SOR_walker_summary$Value[2]}, ΔELPD={SOR_walker_summary$Value[3]}, W={SOR_walker_summary$Value[4]}, BF={BF_SOR_walker_rounded}"))+
  theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))

SOR_walker_plot_main


ggsave(SOR_walker_plot_main, filename = "SOR walker.png", units="cm", width=14, height=8)
ggsave(SOR_walker_plot_main, filename = "SOR walker.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

## Single object report condition sphere

```{r single condition sphere}
SOR_sphere <- 
  reports %>%
  filter(SessionTag=="Addendumer", Condition %in% c("Sphere")) %>%
  
  # adding info on whether reponse was consistent with the disambiguation cues
  mutate(InBiasDirection = (SphereBias == -1 & Percept == "right") | (SphereBias == 1 & Percept == "left")) %>%
  
  # absolute shift
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0","2","4")) %>%
  
  ## ----------- SASHA SAYS -----------
  ## 
  ## You need to change the next bit to compute the proportion of duration
  ## the sphere rotated in the direction of the bias (InBiasDirection column).
  ## Do not call it "Congruent", call it "Consistent" (or something like that), so
  ## that we have one word about two objects (whether they are CONGRUENT in their motion) 
  ## and another word for the sphere alone (whether its rotation in CONSISTENT with the bias).
  ## 
  ## ----------- SASHA SAYS -----------

  # computing Pcongurent for each participant and Shift seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
                   # if value in the brackets is true it'll be considered if not it will not
                   ConsistentDur = sum(Duration[InBiasDirection=="TRUE"]),               ## EXHNAGE IS LEFT OR RIGHT CONGRUENT?!!!!!!!!!!!!!!!!!!!!!
                   Pconsistent = ConsistentDur / TotalDuration) %>%
  dplyr::mutate(PconsistentAdj = Pconsistent*0.999+0.0005)
 # dplyr::group_by(Participant, SphereBiasAbs, SphereBiasAsFactor) %>%
 # dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
         #   CongruentDur = sum(Duration[Percept=="congruent"]),
          #  Pcongruent = CongruentDur / TotalDuration) %>%
  #dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)
```

```{r fitting SOR sphere as a contiuous variable}
set.seed(83661)
SOR_sphere_fit <- brm(PconsistentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=SOR_sphere,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r SOR sphere importance via loo}
SOR_sphere_null_model <- brm(PconsistentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=SOR_sphere)

BF_SOR_sphere = brms::bayes_factor(SOR_sphere_fit, SOR_sphere_null_model)


SOR_sphere_fit <- add_criterion(SOR_sphere_fit, "loo", reloo=TRUE)
SOR_sphere_null_model <- add_criterion(SOR_sphere_null_model, "loo", reloo=TRUE)

SOR_sphere_compare <- loo::loo_compare(list("Shift" = SOR_sphere_fit$criteria$loo,
                                          "Intercept" = SOR_sphere_null_model$criteria$loo))

SOR_sphere_weight <- loo::loo_model_weights(list("Shift" = SOR_sphere_fit$criteria$loo,
                                               "Intercept" = SOR_sphere_null_model$criteria$loo))
BF_SOR_sphere
```

```{r rounding BF SOR sphere}
BF_SOR_sphere_rounded <- round(BF_SOR_sphere$bf,digits=2)
BF_SOR_sphere_rounded

```

```{r SOR sphere summary}
SOR_sphere_summary <-
  fixef(SOR_sphere_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-SOR_sphere_compare[2, 1], 1), "±", round(-SOR_sphere_compare[2, 2], 2)),
         Weight = round(c(SOR_sphere_weight)["Shift"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r fitting SOR Sphere as factor}
set.seed(81810)
SOR_sphere_as_factor_fit <- brm(PconsistentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=SOR_sphere,
                              prior=c(prior(normal(0,10), class="b")))


```

```{r SOR sphere comparison}
SOR_sphere_comparison <-
  fixef(SOR_sphere_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```


```{r plot SOR sphere continous predictions MAIN PLOT}
SOR_sphere_fit_predictions <- predict(SOR_sphere_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

SOR_sphere_inset <-
  tibble(x=0.01, y=0.92, tb=list(SOR_sphere_summary))

SOR_sphere_plot_main <-
  ggplot(data=SOR_sphere_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=SOR_sphere, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pconsistent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift (degrees)", breaks = unique(SOR_sphere$ShiftAbs),
                     sec.axis=dup_axis(name=NULL, labels=(SOR_sphere_comparison$Label))) +
  scale_y_continuous(name="Pconsistent", limits = c(0.5, 1)) +
  plot_theme() +
   labs(subtitle=glue("β={SOR_sphere_summary$Value[1]}, CI={SOR_sphere_summary$Value[2]}, ΔELPD={SOR_sphere_summary$Value[3]}, W={SOR_sphere_summary$Value[4]}, BF={BF_SOR_sphere_rounded}"))+
  theme(legend.position = "none",
        plot.subtitle=element_text(size=10, hjust=0.5))

SOR_sphere_plot_main


ggsave(SOR_sphere_plot_main, filename = "SOR sphere.png", units="cm", width=14, height=8)
ggsave(SOR_sphere_plot_main, filename = "SOR sphere.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

```{r}
SOR_sphere_plot_main /
SOR_walker_plot_main + 
  plot_annotation(tag_levels= "A")

ggsave('figure-04-walker-single.pdf', width=14, height=12, units="cm", device=cairo_pdf)
ggsave('figure-04-walker-single.png', width=14, height=12, units="cm")
```