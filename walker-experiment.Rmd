---
title: "Walker experiment"
author: "Lisa Koßmann, Alexander (Sasha) Pastukhov"
date: "31 1 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

extrafont::loadfonts(quiet = TRUE)
```

```{r libraries}
library(bayestestR)
library(betareg)
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpmisc)
library(ggpubr)
library(glue)
library(ggplot2)
library(grid)
library(patchwork)
library(readr)
library(reshape2)
library(stringr)
library(tibble)
library(tidyr)
```



```{r Tabula rasa}
rm(list=ls())
```


```{r Custom plotting theme}
plot_theme <- 
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
```

# Importing data
```{r Import}
read_walker_csv <- function(filename){
  read_csv(filename, 
           col_types=cols(
                .default = col_double(),
                Participant = col_character(),
                Session = col_character(),
                Block = col_double(),
                OnsetDelay = col_double(),
                Condition = col_character(),
                Percept = col_character(),
                Time = col_double()
              )) %>%
    mutate(SessionTag = ifelse("Shift" %in% names(.), "Addendum", "Main"))
}


reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*walker*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_walker_csv(.$filename[1])) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Session, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%

  # 4. Drop "end" Percept
  filter(Percept != "end")%>%
  
  #5. Renaming Percepts
  mutate(Percept=as.factor(Percept),
         Percept=fct_recode(Percept, "congruent"="up", "incongruent"="down"))
         

```


## Distance vertical condition
```{r}
vertical_distance <- 
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Distance"))%>%
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"0", "1", "2", "3", "4")) %>%
  
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)
```

```{r fitting vertical distance as a continous variable}
set.seed(45950)
vertical_distance_fit <- brm(PcongruentAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=vertical_distance,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r vertical distance importance via loo}
vertical_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=vertical_distance)

BF_vertical_distance<-brms::bayes_factor(vertical_distance_fit, vertical_distance_null_model)

vertical_distance_fit <- add_criterion(vertical_distance_fit, "loo", reloo=TRUE)
vertical_distance_null_model <- add_criterion(vertical_distance_null_model, "loo", reloo=TRUE)

vertical_distance_compare <- loo::loo_compare(list("Distance" = vertical_distance_fit$criteria$loo,
                                          "Intercept" = vertical_distance_null_model$criteria$loo))

vertical_distance_weight <- loo::loo_model_weights(list("Distance" = vertical_distance_fit$criteria$loo,
                                               "Intercept" = vertical_distance_null_model$criteria$loo))

BF_vertical_distance
```
```{r rounding bayes factor}
BF_vertical_distance_rounded <- round(BF_vertical_distance$bf,digits=2)
BF_vertical_distance_rounded


```


```{r vertical distance model summary}
vertical_distance_summary <-
  fixef(vertical_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4),
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-vertical_distance_compare[2, 1], 1), "±", round(-vertical_distance_compare[2, 2], 2)),
         Weight = round(c(vertical_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r number of values above zero vertical distance slope}
posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1))
```
## Vertical distance as factor
```{r fitting vertical distance as factor}
set.seed(96251)
vertical_distance_as_factor_fit <- brm(PcongruentAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(), 
                              data=vertical_distance,
                              cores=future::availableCores(),
                              prior=c(prior(normal(0,10), class="b")))
vertical_distance_comparison <-
  fixef(vertical_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r plotting pariwise comparisons for individual levels of vertical distance}
samples_vertical_distance_as_factor_fit <- posterior_samples(vertical_distance_as_factor_fit)

vertical_distance_levels <- 
  samples_vertical_distance_as_factor_fit %>%
  
  # only retain distace levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "1", "2", "3", "4"))
          
```

```{r Number of values above zero for vertical distance as factor}
vertical_distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```
```{r vertical distance continuous predictions MAIN PLOT}
vertical_distance_fit_predictions <- predict(vertical_distance_fit,
                                            newdata = data.frame(Distance= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
data.frame()%>%
  add_column(Distance= seq(0, 4.2, length.out = 100))

vertical_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(vertical_distance_summary))

vertical_distancePlot_main <-
  ggplot(data=vertical_distance_fit_predictions, 
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=vertical_distance, method="tukeyDense", width=0.1,
                aes(x=Distance, group=Distance, y=Pcongruent)) + 
  scale_x_continuous(name = "Distance [%]",breaks=unique(vertical_distance$Distance), #limits=c(-1,5),
                     sec.axis =  dup_axis(name=NULL, labels=vertical_distance_comparison$Label)) +
  scale_y_continuous(name="Pcongruent") +
  #scale_color_manual(values = c("#000000")) +
  plot_theme + 
   labs(subtitle=glue("β = {vertical_distance_summary$Value[1]}, CI={vertical_distance_summary$Value[2]}, ΔELPD={vertical_distance_summary$Value[3]} , Weight={vertical_distance_summary$Value[4]}, Bayes factor = {BF_vertical_distance_rounded}"))+
  #geom_table_npc(data=vertical_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) + 
  theme(legend.position = "none",
        axis.text.x.top = element_text())

vertical_distancePlot_main

ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.png", units="cm", width=14, height=8)
ggsave(vertical_distancePlot_main, filename = "walker-vertical-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

## Distance horizontal condition

```{r}
horizontal_distance <- 
  reports %>%
  filter(SessionTag == "Addendum", Condition %in% c("Control", "Shift")) %>%
  dplyr::mutate(ShiftAbs = abs(Shift),
                ShiftAsFactor = as.factor(ShiftAbs),
                ShiftAsFactor = fct_relevel(ShiftAsFactor, "0", "1", "2", "3", "4")) %>%
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, ShiftAbs, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)


```

```{r fitting horizontal distance as a contiuous variable}
set.seed(723211)
horizontal_distance_fit <- brm(PcongruentAdj ~ ShiftAbs + (1|Participant),
                    family=Beta(),
                    data=horizontal_distance,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r horizontal distance importance via loo}
horizontal_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=horizontal_distance)

BF_horizontal_distance = brms::bayes_factor(horizontal_distance_fit, horizontal_distance_null_model)


horizontal_distance_fit <- add_criterion(horizontal_distance_fit, "loo", reloo=TRUE)
horizontal_distance_null_model <- add_criterion(horizontal_distance_null_model, "loo", reloo=TRUE)

horizontal_distance_compare <- loo::loo_compare(list("Distance" = horizontal_distance_fit$criteria$loo,
                                          "Intercept" = horizontal_distance_null_model$criteria$loo))

horizontal_distance_weight <- loo::loo_model_weights(list("Distance" = horizontal_distance_fit$criteria$loo,
                                               "Intercept" = horizontal_distance_null_model$criteria$loo))
BF_horizontal_distance
```
```{r horizontal distance summary}
horizontal_distance_summary <-
  fixef(horizontal_distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-horizontal_distance_compare[2, 1], 1), "±", round(-horizontal_distance_compare[2, 2], 2)),
         Weight = round(c(horizontal_distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```


```{r number if values above zero horizontal distance slope}
posterior_samples(horizontal_distance_fit) %>%
  select(b_ShiftAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_ShiftAbs>0), 1))
```


## Horizontal Distance as factor
```{r fitting horizontal distance as factor}
set.seed(878929)
horizontal_distance_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              cores = future::availableCores(),
                              data=horizontal_distance,
                              prior=c(prior(normal(0,10), class="b")))
horizontal_distance_comparison <-
  fixef(horizontal_distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```


```{r plot horizontal distance continous predictions MAIN PLOT}
horizontal_distance_fit_predictions <- predict(horizontal_distance_fit,
                                             newdata = data.frame(ShiftAbs= seq(0, 4.2, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(ShiftAbs = seq(0, 4.2, length.out = 100))

horizontal_distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(horizontal_distance_summary))

horizontal_distance_plot_main <-
  ggplot(data=horizontal_distance_fit_predictions,
      aes(x = ShiftAbs, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=horizontal_distance, method="tukeyDense", width=0.2,
                aes(x=ShiftAbs, group=ShiftAbs, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift [%]", breaks = unique(horizontal_distance$ShiftAbs),
                     sec.axis=dup_axis(name=NULL, labels=(horizontal_distance_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
   labs(subtitle=glue("β = {horizontal_distance_summary$Value[1]}, CI={horizontal_distance_summary$Value[2]}, ΔELPD={horizontal_distance_summary$Value[3]} , Weight={horizontal_distance_summary$Value[4]}, Bayes factor= {BF_horizontal_distance}"))+
  #geom_table_npc(data=horizontal_distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text())

horizontal_distance_plot_main


ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.png", units="cm", width=14, height=8)
ggsave(horizontal_distance_plot_main, filename = "walker-horizontal-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```


```{r plotting pariwise comparisons for individual levels of horizontal distance}
samples_horizontal_distance_as_factor_fit <- posterior_samples(horizontal_distance_as_factor_fit)

horizontal_distance_levels <- 
  samples_horizontal_distance_as_factor_fit %>%
  
  # only retain shift levels
  select(starts_with("b_Shift")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Shift", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Shift = str_remove_all(Shift, "b_ShiftAsFactor"),
         Shift = as.factor(Shift),
         Shift = fct_relevel(Shift, "0", "1", "2", "3", "4"))
```

```{r Number of values above zero for horizontal distance as factor}
horizontal_distance_levels %>%
  group_by(Shift) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```



## Ambiguity sphere condition
```{r}
sphere_ambiguity <- # how do i make it so -1 and -0.25 will be recognized as levels of ambiguiation?
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Sphere ambiguity"))%>%
  dplyr::mutate(SphereDisambiguationAbs = abs(SphereDisambiguation), 
                SphereDisambiguationAsFactor = as.factor(SphereDisambiguationAbs),
                SphereDisambiguationAsFactor = fct_relevel(SphereDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, SphereDisambiguationAbs, SphereDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              
```


```{r fitting sphere ambiguity as a contiuous variable}
set.seed(44279)
sphere_ambiguity_fit <- brm(PcongruentAdj ~ SphereDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=sphere_ambiguity,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r sphere ambiguation importance via loo}
sphere_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=sphere_ambiguity)

BF_sphere_ambiguity = brms::bayes_factor(sphere_ambiguity_fit, sphere_ambiguity_null_model)


sphere_ambiguity_fit <- add_criterion(sphere_ambiguity_fit, "loo", reloo=TRUE)
sphere_ambiguity_null_model <- add_criterion(sphere_ambiguity_null_model, "loo", reloo=TRUE)

sphere_ambiguity_compare <- loo::loo_compare(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                          "Intercept" = sphere_ambiguity_null_model$criteria$loo))

sphere_ambiguity_weight <- loo::loo_model_weights(list("Sphere Disambiguation" = sphere_ambiguity_fit$criteria$loo,
                                               "Intercept" = sphere_ambiguity_null_model$criteria$loo))

```

```{r sphere ambiguity summary}
sphere_ambiguity_summary <-
  fixef(sphere_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-sphere_ambiguity_compare[2, 1], 1), "±",  round(-sphere_ambiguity_compare[2, 2], 2)),
         Weight = round(c(sphere_ambiguity_weight)["Sphere Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")

#sphere_ambiguity_summary<- 
 # subset(sphere_ambiguity_summary, Stat!="β" & Stat!="CI")

#melt(sphere_ambiguity_summary, varnames = names(dimnames(sphere_ambiguity_summary)))

```

## Ambiguity sphere as factor
```{r fitting sphere ambiguity as factor}
set.seed(1495785)
sphere_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ SphereDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=sphere_ambiguity,
                                      cores=future::availableCores(),
                                      prior=c(prior(normal(0,10), class="b")))

sphere_ambiguity_comparison <-
  fixef(sphere_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)

```

```{r plot sphere ambiguity continous predictions  MAIN PLOT}
sphere_ambiguity_fit_predictions <- predict(sphere_ambiguity_fit,
                                             newdata = data.frame(SphereDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(SphereDisambiguationAbs= seq( 0, 1, length.out= 100))

#sphere_ambiguity_summary %>% 
 #  pivot_wider(names_from = Stat, values_from = Value) 

sphere_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(sphere_ambiguity_summary))



sphere_ambiguity_plot_main <-
  ggplot(data=sphere_ambiguity_fit_predictions,
     aes(x = SphereDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=sphere_ambiguity, method="tukeyDense", width= 0.07,
              aes(x=SphereDisambiguationAbs, group=SphereDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(sphere_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
  labs(subtitle=glue("β = {sphere_ambiguity_summary$Value[1]}, CI={sphere_ambiguity_summary$Value[2]}, ΔELPD={sphere_ambiguity_summary$Value[3]} , Weight={sphere_ambiguity_summary$Value[4]}, Bayes factor= {BF_sphere_ambiguity}"))+
    theme(legend.position = "none",
        axis.text.x.top = element_text())
sphere_ambiguity_plot_main

ggsave(sphere_ambiguity_plot_main, filename = "sphere_ambiguity.png", units="cm", width=14, height=8)
ggsave(sphere_ambiguity_plot_main, filename = "sphere-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```
```{r}

```




```{r number if values above zero sphere ambiguity slope}
posterior_samples(sphere_ambiguity_fit) %>%
  select(b_SphereDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_SphereDisambiguationAbs>0), 1))
```



```{r plotting pairwise comparisons for the individual levels of sphere Ambiguity}
samples_sphere_ambiguity_as_factor_fit <- posterior_samples(sphere_ambiguity_as_factor_fit)

sphere_ambiguity_levels <- 
  samples_sphere_ambiguity_as_factor_fit%>%
  select(starts_with("b_SphereDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "SphereDisambiguation", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(SphereDisambiguation = str_remove_all(SphereDisambiguation, "b_SphereDisambiguationAsFactor"),
         SphereDisambiguation = as.factor(SphereDisambiguation),
         SphereDisambiguation = fct_relevel(SphereDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
```

```{r computing values above 0 for sphere Ambiguity as factor}
sphere_ambiguity_levels %>%
  group_by(SphereDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```





## Ambiguity Walker condtion

```{r preprocessing}
walker_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Walker ambiguity"))%>%

  dplyr::mutate(WalkerDisambiguationAbs = abs(WalkerDisambiguation), 
                WalkerDisambiguationAsFactor = as.factor(WalkerDisambiguationAbs),
                WalkerDisambiguationAsFactor = fct_relevel(WalkerDisambiguationAsFactor, "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, WalkerDisambiguationAbs, WalkerDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              


```

```{r fitting walker ambiguity as a contiuous variable}
set.seed(44279)
walker_ambiguity_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAbs + (1|Participant),
                    family=Beta(),
                    data=walker_ambiguity,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0,10), class="b")))

```

```{r walker ambiguation importance via loo}
walker_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=walker_ambiguity)

BF_walker_ambiguity = brms::bayes_factor(walker_ambiguity_fit, walker_ambiguity_null_model)


walker_ambiguity_fit <- add_criterion(walker_ambiguity_fit, "loo", reloo=TRUE)
walker_ambiguity_null_model <- add_criterion(walker_ambiguity_null_model, "loo", reloo=TRUE)

walker_ambiguity_compare <- loo::loo_compare(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                          "Intercept" = walker_ambiguity_null_model$criteria$loo))

walker_ambiguity_weight <- loo::loo_model_weights(list("Walker Disambiguation" = walker_ambiguity_fit$criteria$loo,
                                               "Intercept" = walker_ambiguity_null_model$criteria$loo))

```


```{r walker ambiguity summary}
walker_ambiguity_summary <-
  fixef(walker_ambiguity_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-walker_ambiguity_compare[2, 1], 1), "±", round(-walker_ambiguity_compare[2, 2], 2)),
         Weight = round(c(walker_ambiguity_weight)["Walker Disambiguation"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
#walker_ambiguity_summary<- 
 # subset(walker_ambiguity_summary, Stat!="β" & Stat!="CI")
```


```{r number of values above zero walker ambiguity slope}
posterior_samples(walker_ambiguity_fit) %>%
  select(b_WalkerDisambiguationAbs) %>%
  summarise(PaboveZero = round(100 * mean(b_WalkerDisambiguationAbs>0), 1))
```

## Walker ambiguity as factor

```{r fitting walker ambiguity as factor}
set.seed(582961)
walker_ambiguity_as_factor_fit <- brm(PcongruentAdj ~ WalkerDisambiguationAsFactor + (1|Participant),
                                      family=Beta(), 
                                      data=walker_ambiguity,
                                      cores=future::availableCores(),
                                      prior=c(prior(normal(0,10), class="b")))
walker_ambiguity_comparison <-
  fixef(walker_ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r predictions and MAIN PLOT}
walker_ambiguity_fit_predictions <- predict(walker_ambiguity_fit,
                                             newdata = data.frame(WalkerDisambiguationAbs= seq(0, 1, length.out = 100)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(WalkerDisambiguationAbs= seq( 0, 1, length.out= 100))

walker_ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(walker_ambiguity_summary))

walker_ambiguity_plot_main <-
  ggplot(data=walker_ambiguity_fit_predictions,
     aes(x = WalkerDisambiguationAbs, y=Estimate)) + 
 geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
 geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
 geom_line() + 
 geom_quasirandom(data=walker_ambiguity, method="tukeyDense", width= 0.07,
              aes(x=WalkerDisambiguationAbs, group=WalkerDisambiguationAbs, y=Pcongruent)) + 
 theme(legend.position = "none") + 
 scale_x_continuous(name = "Walker Disambiguation", breaks = unique(walker_ambiguity$WalkerDisambiguationAbs), 
                     sec.axis=dup_axis(name=NULL, labels=(walker_ambiguity_comparison$Label))) +
  scale_y_continuous(name="Pcongruent") +
  plot_theme +
  labs(subtitle=glue("β = {walker_ambiguity_summary$Value[1]}, CI={walker_ambiguity_summary$Value[2]}, ΔELPD={walker_ambiguity_summary$Value[3]} , Weight={walker_ambiguity_summary$Value[4]}, Bayes Factor= {BF_walker_ambiguity}"))+
  #geom_table_npc(data=walker_ambiguity_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text())
walker_ambiguity_plot_main

ggsave(walker_ambiguity_plot_main, filename = "walker_ambiguity.png", units="cm", width=14, height=8)
ggsave(walker_ambiguity_plot_main, filename = "walker-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```


```{r plotting pairwise comparisons for the individual levels of walker Ambiguity}
samples_walker_ambiguity_as_factor_fit <- posterior_samples(walker_ambiguity_as_factor_fit)

walker_ambiguity_levels <- 
  samples_walker_ambiguity_as_factor_fit%>%
  select(starts_with("b_WalkerDisambiguationAsFactor")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "WalkerDisambiguation", values_to = "Beta") %>%

  # turn walker name into a factor
  mutate(WalkerDisambiguation = str_remove_all(WalkerDisambiguation, "b_WalkerDisambiguationAsFactor"),
        WalkerDisambiguation = as.factor(WalkerDisambiguation),
         WalkerDisambiguation = fct_relevel(WalkerDisambiguation, "-1", "-0.25", "0", "0.25", "1"))
          
```


```{r computing values above 0 for walker Ambiguity as factor}
walker_ambiguity_levels %>%
  group_by(WalkerDisambiguation) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

