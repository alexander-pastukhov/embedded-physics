---
title: "Walker experiment"
author: "Lisa Ko√ümann, Alexander (Sasha) Pastukhov"
date: "31 1 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

extrafont::loadfonts(quiet = TRUE)
```

```{r}
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpubr)
library(glue)
library(ggplot2)
library(grid)
library(readr)
library(stringr)
library(tibble)
library(tidyr)
```



```{r Tabula rasa}
rm(list=ls())
```


```{r Custom plotting theme}
plot_theme <- 
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
```

# Importing data
```{r Import}
read_walker_csv <- function(filename){
  read_csv(filename, 
           col_types=cols(
                .default = col_double(),
                Participant = col_character(),
                Session = col_character(),
                Block = col_double(),
                OnsetDelay = col_double(),
                Condition = col_character(),
                Percept = col_character(),
                Time = col_double()
              )) %>%
    mutate(SessionTag = ifelse("Shift" %in% names(.), "Addendum", "Main"))
}


reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*walker*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_walker_csv(.$filename[1])) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Session, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%

  # 4. Drop "end" Percept
  filter(Percept != "end")%>%
  
  #5. Renaming Percepts
  mutate(Percept=as.factor(Percept),
         Percept=fct_recode(Percept, "congruent"="up", "incongruent"="down"))
         
  
walker_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Walker ambiguity"))

```


## Distance vertical condition
```{r}
vertical_distance <- 
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Distance"))%>%
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"0", "1", "2", "3", "4")) %>%
  
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting vertical distance
ggplot(data=vertical_distance,
       aes(x=Distance, group=Distance, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         xlab("Distance [%]")
```

```{r fitting vertical distance as a continous variable}
set.seed(45950)
vertical_distance_fit <- brm(PcongruentAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=vertical_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r vertical distance importance via loo}
vertical_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=vertical_distance)

vertical_distance_fit <- add_criterion(vertical_distance_fit, "loo", reloo=TRUE)
vertical_distance_null_model <- add_criterion(vertical_distance_null_model, "loo", reloo=TRUE)

loo::loo_compare(list("Distance" = vertical_distance_fit$criteria$loo, "Intercept" = vertical_distance_null_model$criteria$loo))

loo::loo_model_weights(list("Distance" = vertical_distance_fit$criteria$loo, "Intercept" = vertical_distance_null_model$criteria$loo))
```

```{r plot vertical distance continuous predictions}
vertical_distance_fit_predictions <- predict(vertical_distance_fit,
                                             newdata = data.frame(Distance= seq( 1, 4, 1)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(Distance= seq( 1, 4, 1))

vertical_distance_plot_main <-
  ggplot(data=vertical_distance_fit_predictions, # lisa, come back here and figure out why you get an error message
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=vertical_distance, method="tukeyDense", width=2,
                aes(x=Distance, group=Distance, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Distance [%]", breaks = unique(vertical_distance$Distance)) +
  plot_theme()

vertical_distance_plot_main
```

```{r plotting vertical distance slope}
vertical_distance_plot_slope <- 
  posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  ggplot(aes(x=b_Distance)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Distance]))

vertical_distance_plot_slope
```

```{r number of values above zero vertical distance slope}
posterior_samples(vertical_distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1))
```
## Vertical distance as factor
```{r fitting vertical distance as factor}
set.seed(96251)
vertical_distance_as_factor_fit <- brm(PcongruentAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(), 
                              data=vertical_distance,
                              prior=c(prior(normal(0,10), class="b")))
```

```{r plotting pariwise comparisons for individual levels of vertical distance}
samples_vertical_distance_as_factor_fit <- posterior_samples(vertical_distance_as_factor_fit)

vertical_distance_levels <- 
  samples_vertical_distance_as_factor_fit %>%
  
  # only retain distace levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "1", "2", "3", "4"))
          
verticaldistancePlot_asFactor <-
ggplot(data=vertical_distance_levels, 
       aes(x = Beta, fill=Distance)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

verticaldistancePlot_asFactor
```

```{r Number of values above zero for vertical distance as factor}
vertical_distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for vertical distance condition}
ggarrange(vertical_distance_plot_main, 
  ggarrange(vertical_distance_plot_slope, verticaldistancePlot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

ggsave("walker-vertical-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```


## Distance horizontal condition

```{r}
horizontal_distance <- 
  reports %>%
  filter(SessionTag == "Addendum", Condition %in% c("Control", "Shift"))%>%
  dplyr::mutate(ShiftAsFactor = as.factor(Shift),
                ShiftAsFactor = fct_relevel(ShiftAsFactor,"-4", "-3", "-2", "-1", "0", "1", "2", "3", "4")) %>%
  ## computing Pcongurent for each participant and distance seperatly
  dplyr::group_by(Participant, Shift, ShiftAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)

# plotting horizontal distance
ggplot(data=horizontal_distance,
       aes(x=Shift, group=Shift, y=Pcongruent, color=Participant))+
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Shift", breaks = unique(horizontal_distance$Shift))
  
  
```

```{r fitting horizontal distance as a contiuous variable}
set.seed(723211)
horizontal_distance_fit <- brm(PcongruentAdj ~ Shift + (1|Participant),
                    family=Beta(),
                    data=horizontal_distance,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```

```{r horizontal distance importance via loo}
horizontal_distance_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=horizontal_distance)

horizontal_distance_fit <- add_criterion(horizontal_distance_fit, "loo", reloo=TRUE)
horizontal_distance_null_model <- add_criterion(horizontal_distance_null_model, "loo", reloo=TRUE)

loo::loo_compare(list("Shift" = horizontal_distance_fit$criteria$loo, "Intercept" = horizontal_distance_null_model$criteria$loo))

loo::loo_model_weights(list("Shift" = horizontal_distance_fit$criteria$loo, "Intercept" = horizontal_distance_null_model$criteria$loo))
```

```{r plot horizontal distance continous predictions}
horizontal_distance_fit_predictions <- predict(horizontal_distance_fit,
                                             newdata = data.frame(Shift= seq( -6, 6, 1)),
                                             probs = c(0.025, 0.25, 0.75, 0.975),
                                             re_formula = NA) %>%
  data.frame()%>%
  add_column(Shift= seq( -6, 6, 1))

horizontal_distance_plot_main <-
  ggplot(data=horizontal_distance_fit_predictions,
      aes(x = Shift, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() + 
  geom_quasirandom(data=horizontal_distance, method="tukeyDense", width=2,
                aes(x=Shift, group=Shift, y=Pcongruent)) + 
  theme(legend.position = "none") + 
  scale_x_continuous(name = "Shift [%]", breaks = unique(horizontal_distance$Shift)) +
  plot_theme

horizontal_distance_plot_main
```

```{r plotting horizontal distance slope}
horizontal_distance_plot_slope <- 
  posterior_samples(horizontal_distance_fit) %>%
  select(b_Shift) %>%
  ggplot(aes(x=b_Shift)) +
  geom_histogram(bins=150) + 
  plot_theme + 
  scale_x_continuous(name = expression(beta[Shift]))

horizontal_distance_plot_slope
```


```{r number if values above zero horizontal distance slope}
posterior_samples(horizontal_distance_fit) %>%
  select(b_Shift) %>%
  summarise(PaboveZero = round(100 * mean(b_Shift>0), 1))
```

## Horizontal Distance as factor
```{r fitting horizontal distance as factor}
set.seed(878929)
horizontal_distance_as_factor_fit <- brm(PcongruentAdj ~ ShiftAsFactor + (1|Participant),
                              family=Beta(), 
                              data=horizontal_distance,
                              prior=c(prior(normal(0,10), class="b")))
```

```{r plotting pariwise comparisons for individual levels of horizontal distance}
samples_horizontal_distance_as_factor_fit <- posterior_samples(horizontal_distance_as_factor_fit)

horizontal_distance_levels <- 
  samples_horizontal_distance_as_factor_fit %>%
  
  # only retain shift levels
  select(starts_with("b_Shift")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Shift", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Shift = str_remove_all(Shift, "b_ShiftAsFactor"),
         Shift = as.factor(Shift),
         Shift = fct_relevel(Shift, "-4", "-3", "-2", "-1", "0", "1", "2", "3", "4")) ## what goes wrong here with the negative values? also maybe a histogram is not the best choice for so many conditions
          
        
horizontal_distance_plot_asFactor <-
ggplot(data=horizontal_distance_levels, 
       aes(x = Beta, fill=Shift)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

horizontal_distance_plot_asFactor
```

```{r Number of values above zero for horizontal distance as factor}
horizontal_distance_levels %>%
  group_by(Shift) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```

```{r combining the plots for horizontal distance condition}
ggarrange(horizontal_distance_plot_main, 
  ggarrange(horizontal_distance_plot_slope, horizontal_distance_plot_asFactor, 
            labels = c("B", "C")),
  labels = c("A"),
  font.label = list(size = 12, color = "black", face =  "bold", family = "Arial"),
  ncol = 1)

#ggsave("walker-horizontal-distance.pdf", width = 12, height=8, units="cm", device=cairo_pdf)
```



## Ambiguity sphere condition
```{r}
sphere_ambiguity <-
  reports %>%
  filter(SessionTag == "Main", Condition %in% c("Control", "Sphere ambiguity"))%>%
  dplyr::mutate(SphereDisambiguationAsFactor = as.factor(SphereDisambiguation),
                SphereDisambiguationAsFactor = fct_relevel(SphereDisambiguationAsFactor,"-1", "-0.25", "0", "0.25", "1")) %>%
  
  ## computing Pcongurent for each participant and disambiguation seperatly
  dplyr::group_by(Participant, SphereDisambiguation, SphereDisambiguationAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CongruentDur = sum(Duration[Percept=="congruent"]),
            Pcongruent = CongruentDur / TotalDuration) %>%
  dplyr::mutate(PcongruentAdj = Pcongruent*0.999+0.0005)              

# plotting SphereDisambiguation 
ggplot(data=sphere_ambiguity,
       aes(x=SphereDisambiguation, group=SphereDisambiguation, y=Pcongruent, color=Participant))+  ## something is really wrong ith ambiguity of -0.25
         geom_boxplot(outlier.shape = NA) +
         geom_beeswarm() +
         theme(legend.position = "none") + 
         scale_x_continuous(name= "Sphere Disambiguation", breaks = unique(sphere_ambiguity$SphereDisambiguation))
```
```{r fitting sphere ambiguity as a contiuous variable}
set.seed(44279)
sphere_ambiguity_fit <- brm(PcongruentAdj ~ Shift + (1|Participant),
                    family=Beta(),
                    data=sphere_ambiguity,
                    cores=future::availableCores(),
                    prior=c(prior(normal(0,10), class="b")))

```


```{r sphere ambiguation importance via loo}
sphere_ambiguity_null_model <- brm(PcongruentAdj ~ (1|Participant),
                           family=Beta(),
                           cores=future::availableCores(),
                           data=sphere_ambiguity)

sphere_ambiguity_fit <- add_criterion(sphere_ambiguity_fit, "loo", reloo=TRUE)
sphere_ambiguity_null_model <- add_criterion(sphere_ambiguity_null_model, "loo", reloo=TRUE)

loo::loo_compare(list("SphereDisambiguation" = sphere_ambiguity_fit$criteria$loo, "Intercept" = sphere_ambiguity_null_model$criteria$loo))

loo::loo_model_weights(list("SphereDisambiguation" = sphere_ambiguity_fit$criteria$loo, "Intercept" = sphere_ambiguity_null_model$criteria$loo))
```
```



## Ambiguity Walker condtiotn

```{r}

```


