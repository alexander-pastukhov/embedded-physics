---
title: "Gears Experiment"
author: "Lisa Koßmann"
date: "13 Dezember 2019"
output:
  html_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(bayestestR)
library(betareg)
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpmisc)
library(glue)
library(ggplot2)
library(grid)
library(patchwork)
library(readr)
library(stringr)
library(tibble)
library(tidyr)

loadfonts(quiet = TRUE)
```

```{r Tabula rasa}
rm(list=ls())
```

```{r Custom plotting theme}
plot_theme <- function(){
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24))
} 

four_colors <- c("#F8766D", "#7CAE00", "#00BFC4", "#C77CFF")                 
```

## Importing data
```{r Import}
reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*gears*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_csv(.$filename[1], 
              col_types = cols(Participant = col_character(),
                               Session = col_character(),
                               Block = col_integer(),
                               OnsetDelay = col_double(),
                               Condition = col_character(),
                               Distance = col_double(),
                               DisplayLeft = col_character(),
                               DisplayRight = col_character(),
                               Occlusion = col_character(),
                               Percept = col_character(),
                               Time = col_double()))) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%
  
  # 4. Drop "end" Percept
  filter(Percept != "end") %>%
  
  # 5. Renaming Displays
  mutate(Percept=as.factor(Percept),
         IsCorotating=(Percept=="left" | Percept=="right"),
         DisplayLeft=as.factor(DisplayLeft),
         DisplayLeft = fct_recode(DisplayLeft, "strong"="gear24-strong",
                                               "medium"= "gear24-medium",
                                               "medium-strong"="gear24-medium-strong",
                                               "weak"="gear24-weak",
                                               "ambiguous"= "gear24"),
         DisplayLeft = fct_relevel(DisplayLeft, "ambiguous", "weak", "medium", "medium-strong", "strong" ),
         DisplayRight=as.factor(DisplayRight),
         DisplayRight=fct_recode(DisplayRight, "strong"="gear24-strong",
                                               "medium-strong"="gear24-medium-strong",
                                               "medium"="gear24-medium",
                                               "weak"="gear24-weak",
                                               "ambiguous"= "gear24"),
        DisplayRight=fct_relevel(DisplayRight, "ambiguous", "weak", "medium", "medium-strong", "strong")) %>%
  mutate(LeftGear = case_when(Percept == "right" ~ "CW", Percept == "left" ~ "CCW", Percept=="up" ~ "CCW", Percept== "down" ~ "CW"),
       RightGear= case_when(Percept== "right" ~"CW", Percept =="left"  ~ "CCW", Percept == "up"~ "CW", Percept== "down" ~ "CCW"))%>%
   
  # 5. Figuring out OTHER gear display. "gear24" for fully ambiguous, other image for disambiguated cases.
  #    Logic: if DisplayLeft == "gear24" then it is "DisplayRight" else it is DisplayLeft.
   mutate(Display = ifelse(DisplayLeft=="ambiguous", as.character(DisplayRight), as.character(DisplayLeft)),
          Display=as.factor(Display),
          Display=fct_relevel(Display,"ambiguous", "weak", "medium", "medium-strong", "strong")) %>% 
  mutate(PrimeGear=ifelse(DisplayLeft=="ambiguous", RightGear, LeftGear),
          PrimeGear=as.factor(PrimeGear))%>%

  
  # 6. Convert Occlusion into numeric. First, change "None" to "0" via stringr::str_replace_all(Occlusion, "None", "0").
  #    Then, convert it to numeric in mutate.
  mutate(OccluderWidth= as.numeric(ifelse(Occlusion=="None", "0", Occlusion)))

```

## Distance condition

```{r distance-data}
distance <-
  reports %>%
  dplyr::filter(Condition=="Control" | Condition=="Separation") %>% 
  dplyr::filter(Percept != "unclear") %>%

  # distance as factor  
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"-8.13", "0", "8.13", "32.52", "65.04")) %>%

  # each participant and Distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CorotateDur = sum(Duration[IsCorotating==TRUE]),
            Pcorotation = CorotateDur / TotalDuration) %>%
  # beta distribution does not like 0 and 1
  dplyr::mutate(PCorotationAdj = Pcorotation * 0.999 + 0.0005)
```

##Fitting distance condition via brms 

```{r Fitting distance as a continuous variable via brms}
# Computing brm for distance condition
set.seed(9578175)
distance_fit <- brm(PCorotationAdj ~ Distance + (1|Participant),
                    family=Beta(),
                    data=distance,
                    refresh=0,
                    cores=future::availableCores(),
                    save_all_pars = TRUE,
                    prior=c(prior(normal(0, 1), class="b")))

distance_null_model <- brm(PCorotationAdj ~ (1|Participant),
                           family=Beta(),
                           refresh=0,
                           cores=future::availableCores(),
                          save_all_pars = TRUE,
                           data=distance)

BF_distance<-brms::bayes_factor(distance_fit, distance_null_model)

BF_distance

BF_distance_rounded <- round(BF_distance$bf,digits=2)
BF_distance_rounded

```


```{r Distance importance via loo}
distance_fit <- add_criterion(distance_fit, "loo", reloo=TRUE)
distance_null_model <- add_criterion(distance_null_model, "loo", reloo=TRUE)

distance_compare <- loo::loo_compare(list("Distance" = distance_fit$criteria$loo,
                                          "Intercept" = distance_null_model$criteria$loo))

distance_weight <- loo::loo_model_weights(list("Distance" = distance_fit$criteria$loo,
                                               "Intercept" = distance_null_model$criteria$loo))
```

```{r distance models summary, include=FALSE}
distance_summary <-
  fixef(distance_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-distance_compare[2, 1], 1), "±", round(-distance_compare[2, 2], 2)),
         Weight = round(c(distance_weight)["Distance"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```

## Distance as factor
```{r fitting distance as factor}
set.seed(9847899)
distance_as_factor_fit <- brm(PCorotationAdj ~ DistanceAsFactor + (1|Participant),
                              family=Beta(),
                              data=distance,
                              refresh=0,
                              prior=c(prior(normal(0,1), class="b")))

distance_comparison <-
  fixef(distance_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```



```{r Plot Distance as continuous predictions}
# predict GROUP-LEVEL Pcorotation
distance_fit_predictions <- predict(distance_fit,
                                    newdata = data.frame(Distance = seq(-10, 70, 1)),
                                    probs = c(0.025, 0.25, 0.75, 0.975),
                                    re_formula = NA) %>%
  data.frame() %>%
  add_column(Distance = seq(-10, 70, 1))

distance_inset <-
  tibble(x=0.01, y=0.92, tb=list(distance_summary))

distancePlot_main <-
  ggplot(data=distance_fit_predictions, 
      aes(x = Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=distance, method="tukeyDense", width=2,
                aes(x=Distance, group=Distance, y=Pcorotation)) + 
  scale_x_continuous(name = "Distance [%]", breaks = unique(distance$Distance),
                     sec.axis =  dup_axis(name=NULL, labels=distance_comparison$Label)) +
  scale_y_continuous(name="Pcorotation") +
  scale_color_manual(values = c("#000000", four_colors)) +
  plot_theme() +
  labs(subtitle=glue("β = distance_summary$Value[1]}, CI={distance_summary$Value[2]}, ΔELPD={distance_summary$Value[3]} , Weight={distance_summary$Value[4]}, Bayes Factor= {BF_distance_rounded}"))+
  #geom_table_npc(data=distance_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text(color=four_colors))
distancePlot_main

ggsave(distancePlot_main, filename = "gears-distance.png", units="cm", width=14, height=8)
ggsave(distancePlot_main, filename = "gears-distance.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```
```{r practical significance distance-fit predictions}
p_significance(
  distance_fit_predictions,
  threshold = "default",
  effects = c("all"),
  component = c("all"),
)
#p_significance(distance_fit_predictions, threshold = "default")
```

```{r No of values above 0 distance slope}
## computing values above 0
posterior_samples(distance_fit) %>%
  select(b_Distance) %>%
  summarise(PaboveZero = round(100 * mean(b_Distance>0), 1)) %>%
  pull(PaboveZero)

```


```{r plotting pairwise comparisons for the individual levels of Distance}
samples_distance_as_factor_fit <- posterior_samples(distance_as_factor_fit)

distance_levels <- 
  samples_distance_as_factor_fit %>%
  
  # only retain distacn levels
  select(starts_with("b_Distance")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Distance", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Distance = str_remove_all(Distance, "b_DistanceAsFactor"), 
         Distance = as.factor(Distance),
         Distance = fct_relevel(Distance, "-8.13", "0", "8.13", "32.52", "65.04"))

distance_means <- 
  distance_levels %>%
  group_by(Distance) %>%
  summarise(Beta = round(median(Beta), 2))
          
distancePlot_asFactor <-
  ggplot(data=distance_levels, 
       aes(x = Beta, fill=Distance)) + 
  geom_histogram(position="identity", alpha=0.5, bins=200) + 
  scale_x_continuous(expression(Beta[i]),
                     sec.axis = dup_axis(name = element_blank(),
                    breaks = distance_means$Beta,
                    labels = glue("{distance_means$Distance}%"))) +
  plot_theme ()+ 
  theme(legend.position = "none",
        axis.ticks.x.top = element_line(color=four_colors),
        axis.text.x.top = element_text(color=four_colors))

distancePlot_asFactor
```

```{r Number of values above zero distance as factor}
distance_levels %>%
  group_by(Distance) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```




## Occlusion Condition
```{r occlusion data}
#Computing Occlusion Duration
occlusion<- reports%>%
  dplyr::filter(Condition=="Control"|Condition=="Occlusion") %>%
  dplyr::filter(Percept!="unclear") %>%
  
  # replace "None" with "0" and then turn Occlusion to a numeric variable
 dplyr:: mutate(Occlusion = ifelse(Occlusion == "None", "0", Occlusion), 
         Occlusion = as.numeric(Occlusion)) %>%
  
  # reorder Occlusion to factor
  # 1. Display to factor
 dplyr:: mutate(Display=as.factor(Display),
         OcclusionAsFactor=as.factor(Occlusion),
         OcclusionAsFactor=fct_relevel(OcclusionAsFactor, "0","8.13", "16.26", "32.52", "65.04")) %>%
  
  # 2. Use fct_relevel function, which goes Var = fct_relevel(Var, "first level", "second level", ...)
  # each participant and Occlusion seperatly
  dplyr::group_by(Participant, Occlusion, OcclusionAsFactor) %>% 
  dplyr::summarize(TotalDuration = sum(Duration),
           #if value in the brackets is true itll be considered if not it will not
            CorotateDur = sum(Duration[IsCorotating == TRUE]),
            Pcorotation = CorotateDur / TotalDuration)%>%
  
 dplyr:: mutate(PCorotationAdj = Pcorotation*0.999+0.0005)
```
## Fitting occlusion condition via brms

```{r Fitting occlusion as a continuous variable}
# Computing brm for Occlusion condition
set.seed(9789931)
occlusion_fit <- brm(PCorotationAdj ~ Occlusion + (1|Participant),
                     family=Beta(),
                     data=occlusion,
                     refresh = 0,
                     save_all_pars = TRUE,
                     prior=c(prior(normal(0,1), class="b")))

occlusion_null_model <- brm(PCorotationAdj ~ (1|Participant),
                           family=Beta(),
                           refresh=0,
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=occlusion)

BF_occlusion<-brms::bayes_factor(occlusion_fit, occlusion_null_model)

BF_occlusion

BF_occlusion_rounded <- round(BF_occlusion$bf,digits=2)
BF_occlusion_rounded
```

```{r Occlusion importance via loo}
occlusion_fit <- add_criterion(occlusion_fit, "loo", reloo=TRUE)
occlusion_null_model <- add_criterion(occlusion_null_model, "loo", reloo=TRUE)

occlusion_compare <- loo::loo_compare(list("Occlusion" = occlusion_fit$criteria$loo,
                                          "Intercept" = occlusion_null_model$criteria$loo))

occlusion_weight <- loo::loo_model_weights(list("Occlusion" = occlusion_fit$criteria$loo,
                                               "Intercept" = occlusion_null_model$criteria$loo))
```

```{r creating occlusion summary}
occlusion_summary <-
  fixef(occlusion_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-occlusion_compare[2, 1], 1), "±",  round(-occlusion_compare[2, 2], 2)),
         Weight = round(c(occlusion_weight)["Occlusion"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")
```



## Occlusion as factor

```{r fitting occlusion as factor}
#  Computing brm for Occlusion as factor condition
set.seed(89925355)
occlusion_as_factor_fit <- brm(PCorotationAdj ~ OcclusionAsFactor + (1|Participant),
                               family=Beta(),
                               data=occlusion,
                               refresh=0,
                               prior=c(prior(normal(0,10), class="b")))

occlusion_comparison <-
  fixef(occlusion_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r Plot Occlusion as continuous predictions}
# predict GROUP-LEVEL Pcorotation
occlusion_fit_predictions <- predict(occlusion_fit,
                                    newdata = data.frame(Occlusion = seq(-10, 70, 1)),
                                    probs = c(0.025, 0.25, 0.75, 0.975),
                                    re_formula = NA) %>%
  data.frame() %>%
  add_column(Occlusion = seq(-10, 70, 1))

occlusion_inset <-
  tibble(x=0.01, y=0.92, tb=list(occlusion_summary))

occlusionPlot_main <-
  ggplot(data=occlusion_fit_predictions, 
      aes(x = Occlusion, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q2.5, ymax=Q97.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=occlusion, method="tukeyDense", width=2,
                aes(x=Occlusion, group=Occlusion, y=Pcorotation)) + 
  scale_x_continuous(name = "Occlusion [%]", breaks = unique(occlusion$Occlusion),
                     sec.axis =  dup_axis(name=NULL, labels=occlusion_comparison$Label)) +
  scale_y_continuous(name="Pcorotation") +
  scale_color_manual(values = c("#000000", four_colors)) +
  plot_theme() + 
  labs(subtitle=glue("β = {occlusion_summary$Value[1]}, CI={occlusion_summary$Value[2]}, ΔELPD={occlusion_summary$Value[3]} , Weight={occlusion_summary$Value[4]}, Bayes Factor= {BF_occlusion_rounded}"))+
  #geom_table_npc(data=occlusion_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text(color=four_colors))
occlusionPlot_main

ggsave(occlusionPlot_main, filename = "gears-occlusion.png", units="cm", width=14, height=8)
ggsave(occlusionPlot_main, filename = "gears-occlusion.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```
```{r No of values above 0 occlusion slope}
## computing values above 0
posterior_samples(occlusion_fit) %>%
  select(b_Occlusion) %>%
  summarise(PaboveZero = round(100 * mean(b_Occlusion>0), 1)) %>%
  pull(PaboveZero)

```

```{r plotting pairwise comparisons for the individual levels of occlusion}
samples_occlusion_as_factor_fit <- posterior_samples(occlusion_as_factor_fit)

occlusion_levels <- 
  samples_occlusion_as_factor_fit %>%
  
  # only retain Occlusion levels
  select(starts_with("b_Occlusion")) %>%
  
  # wide to long
  pivot_longer(cols=everything(), names_to = "Occlusion", values_to = "Beta") %>%

  # turn occlusion name into a factor
  mutate(Occlusion = str_remove_all(Occlusion, "b_OcclusionAsFactor"), 
         Occlusion = as.factor(Occlusion),
         Occlusion = fct_relevel(Occlusion, "8.13", "16.26", "32.52", "65.04"))

occlusion_means <- 
  occlusion_levels %>%
  group_by(Occlusion) %>%
  summarise(Beta = round(median(Beta), 2))

occlusionPlot_asFactor<- 
  ggplot(data=occlusion_levels, 
       aes(x = Beta, fill=Occlusion)) + 
  geom_histogram(alpha=0.75, position="identity", bins=150)+
  scale_x_continuous(expression(Beta[i]), 
                    sec.axis = dup_axis(name = element_blank(),
                    breaks = occlusion_means$Beta,
                    labels = glue("{occlusion_means$Occlusion}%")))+
  plot_theme()+
  theme(legend.position = "none",
        axis.text.x.top = element_text(color=four_colors),
        axis.ticks.x.top = element_line(color=four_colors))

occlusionPlot_asFactor
```

```{r computing values above 0 for Occlusion as factor}
occlusion_levels %>%
  group_by(Occlusion) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))
```




## Ambiguity Condition
```{r}
##Computing Ambiguity Duration
ambiguity<- reports%>%
  filter(Condition=="Control"|Condition=="Ambiguity")%>% 
  filter(Percept!="unclear")%>%
  
  # 1. Display to factor                 ## isnt this part of preprossessing now?
  # 2. Rename levels using fct_recode
  # 3. Reorder Display
  
  # each participant and Ambiguity seperatly
  group_by(Participant, Display)%>% 
  summarize(TotalDuration=sum(Duration),
  
  # if value in the brackets is true itll be considered if not it will not
  CorotateDur=sum(Duration[IsCorotating== TRUE]),
  Pcorotation=CorotateDur/TotalDuration)%>%
  mutate(PCorotationAdj=Pcorotation*0.999+0.0005)

```



```{r fitting ambiguity as factor}
set.seed(99435)
ambiguity_as_factor_fit <- brm(PCorotationAdj ~ Display +(1|Participant),
                     family= Beta(),
                     data= ambiguity,
                     refresh=0,
                     cores=future::availableCores(),
                     save_all_pars = TRUE,
                     prior=c(prior(normal(0, 1), class="b")))

ambiguity_comparison <-
  fixef(ambiguity_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r predicting and plotting ambiguity}
ambiguity_fit_predictions <- predict(ambiguity_as_factor_fit,
                                     newdata = data.frame(Display = levels(ambiguity$Display)),
                                     summary = FALSE,
                                     re_formula = NA) %>%
  data.frame() %>%
  pivot_longer(everything(), names_to = "Display", values_to = "Pcorotation") %>%
  mutate(Display = factor(Display, levels = sort(unique(Display)), labels = levels(ambiguity$Display)))
  

ambiguity_fit_moments <-
  ambiguity_fit_predictions %>%
  group_by(Display) %>%
  summarise(meanP = mean(Pcorotation),
            medianP= median(Pcorotation))


```

```{r Ambiguity importance via loo}
ambiguity_null_model <- brm(PCorotationAdj ~ (1|Participant),
                           family=Beta(),
                           refresh=0,
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=ambiguity)

BF_ambiguity_as_factor<-brms::bayes_factor(ambiguity_as_factor_fit, ambiguity_null_model)

BF_ambiguity_as_factor

BF_ambiguity_as_factor_rounded <- round(BF_ambiguity_as_factor$bf,digits=2)
BF_ambiguity_as_factor_rounded

ambiguity_as_factor_fit <- add_criterion(ambiguity_as_factor_fit, "loo", reloo=TRUE)
ambiguity_null_model <- add_criterion(ambiguity_null_model, "loo", reloo=TRUE)

ambiguity_compare <- loo::loo_compare(list("Display" = ambiguity_as_factor_fit$criteria$loo,
                                          "Intercept" = ambiguity_null_model$criteria$loo))

ambiguity_weight <- loo::loo_model_weights(list("Display" = ambiguity_as_factor_fit$criteria$loo,
                                               "Intercept" = ambiguity_null_model$criteria$loo))
```

```{r ambiguity summary}
ambiguity_summary1 <-
  fixef(ambiguity_as_factor_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-ambiguity_compare[2, 1], 1), "±",  round(-ambiguity_compare[2, 2], 2)),
         Weight = round(c(ambiguity_weight)["Display"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")

ambiguity_summary<- 
  subset(ambiguity_summary1, Stat!="β" & Stat!="CI")
```

 

```{r plotting ambiguity}
ambiguity_inset <-
  tibble(x=0.01, y=0.92, tb=list(ambiguity_summary))

ambiguityPlot_main <-
  ggplot(data=ambiguity_fit_predictions, 
      aes(x = as.numeric(Display), group=Display, y=Pcorotation)) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_violin(data = ambiguity_fit_predictions, aes(x=as.numeric(Display)), 
              fill="gray64", color="white", draw_quantiles = c(0.5)) +
  geom_quasirandom(data=ambiguity, method="tukeyDense", width=0.1,
                aes(x=as.numeric(Display), group=Display, y=Pcorotation)) +
  scale_x_continuous(name="Display",
                     breaks = unique(as.numeric(ambiguity$Display)),
                     labels = c("ambiguous","weak", "medium","medium-strong","strong"),
                     sec.axis =  dup_axis(name = element_blank(),
                                          labels = ambiguity_comparison$Label))+
  scale_y_continuous(name="Pcorotation") +
  scale_color_manual(values = c("#000000", four_colors)) +
  plot_theme() +
   labs(subtitle=glue("β = {ambiguity_summary$Value[1]}, CI={ambiguity_summary$Value[2]}, ΔELPD={ambiguity_summary$Value[3]} , Weight={ambiguity_summary$Value[4]}, Bayes Factor= {BF_ambiguity_as_factor_rounded}"))+
  #geom_table_npc(data=ambiguity_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text(color=four_colors))
ambiguityPlot_main

ggsave(ambiguityPlot_main, filename = "gears-ambiguity.png", units="cm", width=14, height=8)
ggsave(ambiguityPlot_main, filename = "gears-ambiguity.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```

```{r plotting pairwise comparisons for the individual levels of Ambiguity}
samples_ambiguity_as_factor_fit <- posterior_samples(ambiguity_as_factor_fit)

ambiguity_levels <- 
  samples_ambiguity_as_factor_fit%>%
  select(starts_with("b_Display")) %>%
  
  # wide to long
  pivot_longer(cols= everything(), names_to = "Display", values_to = "Beta") %>%

  # turn distance name into a factor
  mutate(Display = str_remove_all(Display, "b_Display"),
         Display = as.factor(Display),
         Display = fct_relevel(Display, "ambiguous", "weak", "medium", "medium-strong", "Strong"))
ambiguityPlot_asFactor <-
ggplot(data=ambiguity_levels, 
       aes(x = Beta, fill=Display)) + 
  geom_histogram(alpha=0.5, position="identity", bins=150) + 
  scale_x_continuous(expression(Beta[i])) +
  plot_theme() + 
   theme(
    legend.position = c(.05, 0.95),
    legend.justification = c("left", "top"),
    legend.box.just = "left",
    legend.text=element_text(size=8, family="Arial"),
    legend.title = element_text(size=10, family="Arial"),
    legend.margin = margin(6, 6, 6, 6))

ambiguityPlot_asFactor
```

```{r computing values above 0 for Ambiguity as factor}
ambiguity_levels %>%
  group_by(Display) %>%
  summarize(numAbove=sum(Beta > 0),
            TotalBeta=n(),
            Pbetaabove= round(100 * (numAbove/TotalBeta), 1))

```

## Disambiguation check
```{r Proportion of clockwise}
disambiguation<- reports%>%
  filter(Condition=="Control"|Condition=="Ambiguity")%>% 
  filter(Percept!="unclear")%>%
  
  group_by(Participant, Display)%>% 
  summarize(TotalDuration=sum(Duration),
    ClockwiseDur=sum(Duration[PrimeGear=="CW"]),
    PClockwise=ClockwiseDur/TotalDuration)%>%
  mutate(PClockwiseAdj=PClockwise*0.999+0.0005)
```

```{r fitting disambiguation/ambiguity as factor}
set.seed(5516800)
disambiguation_as_factor_fit <- brm(PClockwiseAdj ~ Display +(1|Participant),
                     family= Beta(),
                     data= disambiguation,
                     refresh=0,
                     cores=future::availableCores(),
                     save_all_pars = TRUE,
                     prior=c(prior(normal(0, 1), class="b")))

disambiguation_comparison <-
  fixef(disambiguation_as_factor_fit) %>%
              data.frame() %>%
              rownames_to_column("Factor") %>%
              mutate(Est = ifelse(Factor == "Intercept", 
                                  "Control\ncondition", 
                                  glue("β={round(Estimate, 2)}\n{round(Q2.5, 1)}..{round(Q97.5, 1)}"))) %>%
  select(Est) %>%
  rename(Label = Est)
```

```{r predicting and plotting disambiguation/ambiguity}
disambiguation_fit_predictions <- predict(disambiguation_as_factor_fit,
                                     newdata = data.frame(Display = levels(disambiguation$Display)),
                                     summary = FALSE,
                                     re_formula = NA) %>%
  data.frame() %>%
  pivot_longer(everything(), names_to = "Display", values_to = "PClockwise") %>%
  mutate(Display = factor(Display, levels = sort(unique(Display)), labels = levels(disambiguation$Display)))
  

disambiguation_fit_moments <-
  disambiguation_fit_predictions %>%
  group_by(Display) %>%
  summarise(meanP = mean(PClockwise),
            medianP= median(PClockwise))


```

```{r disambiguation/ambiguity importance via loo}
disambiguation_null_model <- brm(PClockwiseAdj ~ (1|Participant),
                           family=Beta(),
                           refresh=0,
                           cores=future::availableCores(),
                           save_all_pars = TRUE,
                           data=disambiguation)

BF_disambiguation_as_factor<-brms::bayes_factor(disambiguation_as_factor_fit, disambiguation_null_model)

BF_disambiguation_as_factor

BF_disambiguation_as_factor_rounded <- round(BF_disambiguation_as_factor$bf,digits=2)
BF_disambiguation_as_factor_rounded

disambiguation_as_factor_fit <- add_criterion(disambiguation_as_factor_fit, "loo", reloo=TRUE)
disambiguation_null_model <- add_criterion(disambiguation_null_model, "loo", reloo=TRUE)

disambiguation_compare <- loo::loo_compare(list("Display" = disambiguation_as_factor_fit$criteria$loo,
                                          "Intercept" = disambiguation_null_model$criteria$loo))

disambiguation_weight <- loo::loo_model_weights(list("Display" = disambiguation_as_factor_fit$criteria$loo,
                                               "Intercept" = disambiguation_null_model$criteria$loo))
```

```{r disambiguation/ambiguity summary}
disambiguation_summary <-
  fixef(disambiguation_as_factor_fit) %>%
  data.frame() %>%
  slice(n()) %>% 
  mutate(`β` = round(Estimate, 4), 
         CI = glue("{round(Q2.5, 2)}..{round(Q97.5, 2)}")) %>%
  select(`β`, CI) %>%
  mutate("ΔELPD" = stringr::str_c(round(-disambiguation_compare[2, 1], 1), "±",  round(-disambiguation_compare[2, 2], 2)),
         Weight = round(c(disambiguation_weight)["Display"], 2)) %>%
  mutate_all(as.character) %>%
  pivot_longer(everything(), names_to = "Stat", values_to = "Value")

disambiguation_summary<- 
  subset(disambiguation_summary, Stat!="β" & Stat!="CI")
```

 

```{r plotting disambiguation}
disambiguation_inset <-
  tibble(x=0.01, y=0.92, tb=list(disambiguation_summary))

disambiguationPlot_main <-
  ggplot(data=disambiguation_fit_predictions, 
      aes(x = as.numeric(Display), group=Display, y=PClockwise)) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_violin(data = disambiguation_fit_predictions, aes(x=as.numeric(Display)), 
              fill="gray64", color="white", draw_quantiles = c(0.5)) +
  geom_quasirandom(data=disambiguation, method="tukeyDense", width=0.1,
                aes(x=as.numeric(Display), group=Display, y=PClockwise)) +
  scale_x_continuous(name="Display",
                     breaks = unique(as.numeric(disambiguation$Display)),
                     labels = c("ambiguous","weak", "medium","medium-strong","strong"),
                     sec.axis =  dup_axis(name = element_blank(),
                                          labels = disambiguation_comparison$Label))+
  scale_y_continuous(name="Pclockwise") +
  scale_color_manual(values = c("#000000", four_colors)) +
  plot_theme() +
  labs(subtitle=glue("β = {disambiguation_summary$Value[1]}, CI={disambiguation_summary$Value[2]}, Bayes factor = {BF_disambiguation_as_factor_rounded}"))+
 # geom_table_npc(data=disambiguation_inset, aes(npcx=x, npcy=y, label= tb), size=8 * 0.35) +
  theme(legend.position = "none",
        axis.text.x.top = element_text(color=four_colors))
  disambiguationPlot_main

ggsave(disambiguationPlot_main, filename = "gears-disambiguation.png", units="cm", width=14, height=8)
ggsave(disambiguationPlot_main, filename = "gears-disambiguation.pdf", units="cm", width=14, height=8, device=cairo_pdf)
```