---
title: "Gears Experiment"
author: "Lisa Koßmann"
date: "13 Dezember 2019"
output:
  html_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(bayestestR)
library(betareg)
library(boot)
library(brms)
library(dplyr)
library(extrafont)
library(fs)
library(forcats)
library(ggbeeswarm)
library(ggpmisc)
library(glue)
library(ggplot2)
library(grid)
library(patchwork)
library(readr)
library(stringr)
library(tibble)
library(tidyr)

loadfonts(quiet = TRUE)
```

```{r Tabula rasa}
rm(list=ls())
```

## Utilities


### Custom plotting theme
```{r Custom plotting theme}
plot_theme <- function(){
  theme(text=element_text(family="Arial"),
        axis.text.x = element_text(size = 8, colour = 'black'), 
        axis.text.y = element_text(size = 8, colour = 'black'), 
        axis.title.x = element_text(size = 10), 
        axis.title.y = element_text(size = 10), 
        panel.grid.minor.x = element_blank(), 
        panel.grid.minor.y =  element_line(size = 0.24), 
        axis.ticks = element_line(size = 0.24),
        plot.subtitle=element_text(size=8, hjust=0.5))
} 
```

### Computing comparisons between the two models
```{r compute BF}
compute_BF <- function(full_model, reduced_model){
  BF <- brms::bayes_factor(full_model, reduced_model, silent = TRUE)
  sprintf('BF=%.2g', BF$bf)
}
```

```{r compute dELPD}
compute_dELPD <- function(full_model, intercept_model){
  dLOO <-   
    loo::loo_compare(list("Term" = full_model$criteria$loo,
                          "Intercept" = intercept_model$criteria$loo)) %>%
    data.frame() %>%
    rownames_to_column("Coefficient") %>%
    
    # invert difference, so it is positive if full model is better (and negative if it worse than intercept only)
    mutate(elpd_diff = ifelse(Coefficient == "Intercept", -elpd_diff, elpd_diff)) %>%
    slice(2)
    
  sprintf("ΔELPD=%.1f±%.2f", dLOO$elpd_diff[1], dLOO$se_diff[1])
}
```

```{r compute full model weight}
compute_full_model_weight <- function(full_model, intercepts_model){
  full_model_weight <- 
    loo::loo_model_weights(list("Term" = full_model$criteria$loo,
                                "Intercept" = intercepts_model$criteria$loo))["Term"]
  
  sprintf("W=%.2f", full_model_weight)
}
```

```{r compare two models}
compare_models <- function(perceptual_coupling, independent_model, physics){
  models_elpd <- 
    loo::loo_compare(list("Perceptual Coupling" = perceptual_coupling$criteria$loo,
                          "Independent" = independent_model$criteria$loo,
                          "Physics"= physics$criteria$loo)) %>%
      data.frame() %>%
      rownames_to_column("Model")%>%
  mutate(dELPD=(sprintf("%.1f±%.2f", elpd_diff, se_diff))) %>%
  select(Model, dELPD)

  models_weight <-
    loo::loo_model_weights(list("Perceptual Coupling" = perceptual_coupling$criteria$loo,                          "Independent" = independent_model$criteria$loo, "Physics" = physics$criteria$loo))%>%
    data.matrix()%>%
    data.frame()%>%
  rownames_to_column("Model")%>%
    mutate( Weight= (sprintf("%.2f", .)))%>%
    select(Model, Weight)

  models_alpha <-
    purrr::map_df(list("Perceptual Coupling" = perceptual_coupling, 
                     "Independent" = independent_model, 
                     "Physics" = physics), ~compute_model_alpha(.)) %>%
    t() %>%
    data.frame() %>%
    rename(a = 1) %>%
    rownames_to_column("Model")

  models_beta <-
    purrr::map_df(list("Perceptual Coupling" = perceptual_coupling, 
                     "Independent" = independent_model, 
                     "Physics" = physics), ~compute_model_beta(.)) %>%
    t() %>%
    data.frame() %>%
    rename(b = 1) %>%
    rownames_to_column("Model")
  
  purrr::reduce(list(models_elpd, models_weight, models_alpha, models_beta), dplyr::left_join, by="Model")
}
```

### Computation of coefficient estimates and their 89% credible intervals

```{r full model beta}
compute_model_beta <- function(brms_model){
  estimate <- 
    fixef(brms_model, probs = c((1-0.89)/2, 1-(1-0.89)/2)) %>%
    data.frame() %>%
    rownames_to_column("Coefficient") %>%
    rename(LowerCI=4, UpperCI=5) %>%
    filter(Coefficient %in% c("Term", "NotInteracting"))
  
  if (nrow(estimate) == 0){
    return("-")
  }
  sprintf('%.4f [%0.2f..%0.2f]', exp(estimate$Estimate), exp(estimate$LowerCI), exp(estimate$UpperCI))
}
```

```{r full model alpha}
compute_model_alpha <- function(brms_model){
  alpha <-
    fixef(brms_model,probs= c((1-0.89)/2, 1-(1-0.89)/2)) %>%
    data.frame()%>%
    rownames_to_column("Coefficient")%>%
    rename(LowerCI=4, UpperCI=5) %>%
    filter(Coefficient == "Intercept")
sprintf('%.2f [%0.2f..%0.2f]',inv.logit(alpha$Estimate),
        inv.logit(alpha$LowerCI), inv.logit(alpha$UpperCI))
  }
```

```{r factor model pairwise betas}
compute_factor_level_betas <- function(factor_model){
  fixef(factor_model, probs = c((1-0.89)/2, 1-(1-0.89)/2)) %>%
    data.frame() %>%
    rownames_to_column("Coefficient") %>%
    rename(LowerCI=4, UpperCI=5) %>%
    mutate(Label = ifelse(Coefficient == "Intercept", 
                          "Control\ncondition", 
                           glue("β={round(exp(Estimate), 2)}\n{round(exp(LowerCI), 1)}..{round(exp(UpperCI), 1)}"))) %>%
    pull(Label)
}
```

### Wrapper for commom parameters of the BRMS update 
```{r brms prototype fit}
fit_prototype <- function(prototype, data, add_loo=TRUE){
  fit <- 
    update(prototype,
           newdata=data,
           refresh=0,
           cores=future::availableCores(),
           save_all_pars=TRUE)
  
  if (add_loo){
    fit <- add_criterion(fit, "loo", reloo=TRUE)
  }
  fit
}
```

## Importing data

```{r Import}
reports <- 
  # 1. Figure out which files need to be loaded
  tibble(filename = as.character(dir_ls(path = "Data", glob  = "*gears*.csv"))) %>%
  
  # 2. Load files on by one (hence rowwise())
  rowwise() %>%
  do(read_csv(.$filename[1], 
              col_types = cols(Participant = col_character(),
                               Session = col_character(),
                               Block = col_integer(),
                               OnsetDelay = col_double(),
                               Condition = col_character(),
                               Distance = col_double(),
                               DisplayLeft = col_character(),
                               DisplayRight = col_character(),
                               Occlusion = col_character(),
                               Percept = col_character(),
                               Time = col_double()))) %>%
  ungroup() %>%
  
  # 3. Compute duration PER BLOCK. Inside mutate use "lead(Time)".
  group_by(Participant, Block) %>%
  mutate(Duration = lead(Time) - Time) %>%
  ungroup() %>%
  
  # 4. Drop "end" Percept
  filter(Percept != "end") %>%
  
  # 5. Renaming Displays
  mutate(Percept=as.factor(Percept),
         IsCorotating=(Percept=="left" | Percept=="right"),
         DisplayLeft=as.factor(DisplayLeft),
         DisplayLeft = fct_recode(DisplayLeft, "strong"="gear24-strong",
                                               "medium"= "gear24-medium",
                                               "medium-strong"="gear24-medium-strong",
                                               "weak"="gear24-weak",
                                               "ambiguous"= "gear24"),
         DisplayLeft = fct_relevel(DisplayLeft, "ambiguous", "weak", "medium", "medium-strong", "strong" ),
         DisplayRight=as.factor(DisplayRight),
         DisplayRight=fct_recode(DisplayRight, "strong"="gear24-strong",
                                               "medium-strong"="gear24-medium-strong",
                                               "medium"="gear24-medium",
                                               "weak"="gear24-weak",
                                               "ambiguous"= "gear24"),
        DisplayRight=fct_relevel(DisplayRight, "ambiguous", "weak", "medium", "medium-strong", "strong")) %>%
  mutate(LeftGear = case_when(Percept == "right" ~ "CW", Percept == "left" ~ "CCW", Percept=="up" ~ "CCW", Percept== "down" ~ "CW"),
       RightGear= case_when(Percept== "right" ~"CW", Percept =="left"  ~ "CCW", Percept == "up"~ "CW", Percept== "down" ~ "CCW"))%>%
   
  # 5. Figuring out OTHER gear display. "gear24" for fully ambiguous, other image for disambiguated cases.
  #    Logic: if DisplayLeft == "gear24" then it is "DisplayRight" else it is DisplayLeft.
   mutate(Display = ifelse(DisplayLeft=="ambiguous", as.character(DisplayRight), as.character(DisplayLeft)),
          Display=as.factor(Display),
          Display=fct_relevel(Display,"ambiguous", "weak", "medium", "medium-strong", "strong")) %>% 
  mutate(PrimeGear=ifelse(DisplayLeft=="ambiguous", RightGear, LeftGear),
          PrimeGear=as.factor(PrimeGear))%>%

  
  # 6. Convert Occlusion into numeric. First, change "None" to "0" via stringr::str_replace_all(Occlusion, "None", "0").
  #    Then, convert it to numeric in mutate.
  mutate(OccluderWidth= as.numeric(ifelse(Occlusion=="None", "0", Occlusion)))%>%
  
  mutate(NotInteracting= as.integer((Distance > "-8.13")))

```

## Distance condition

```{r distance-data}
distance <-
  reports %>%
  dplyr::filter(Condition=="Control" | Condition=="Separation") %>% 
  dplyr::filter(Percept != "unclear") %>%

  # distance as factor  
  dplyr::mutate(DistanceAsFactor = as.factor(Distance),
                DistanceAsFactor = fct_relevel(DistanceAsFactor,"-8.13", "0", "8.13", "32.52", "65.04")) %>%

  # each participant and Distance seperatly
  dplyr::group_by(Participant, Distance, DistanceAsFactor) %>%
  dplyr::summarize(TotalDuration = sum(Duration),
            # if value in the brackets is true it'll be considered if not it will not
            CounterrotateDur = sum(Duration[!IsCorotating]),
            Pcounterrotate = CounterrotateDur / TotalDuration) %>%

  # beta distribution does not like 0 and 1
  dplyr::mutate(Padj = Pcounterrotate * 0.999 + 0.0005) %>%
  
  # duplicating distance as Term for common BRMS model use
  dplyr::mutate(Term = Distance,
                TermAsFactor = DistanceAsFactor)%>%
  dplyr::mutate(NotInteracting= as.integer((Distance > "-8.13")))

```

### Precompiling BRMS models, so we can reuse them

```{r brms models}
perceptual_coupling_prototype <- brm(Padj ~ Term + (1|Participant),
                     family=Beta(),
                     data=distance,
                     chains=0, # this means that model is never sampled
                     prior=c(prior(normal(0, 1), class="b")))

independent_prototype <- brm(Padj ~ (1|Participant),
                           family=Beta(),
                           chains=0, # this means that model is never sampled
                           data=distance)

physics_prototype <- brm(Padj ~ NotInteracting + (1|Participant),
                         family = Beta(),
                         data= distance,
                         chains=0, 
                         prior=c(prior(normal(0, 1), class="b")))

pairwise_comparison_prototype <- brm(Padj ~ TermAsFactor + (1|Participant),
                        family=Beta(),
                        data=distance,
                        chains=0, # this means that model is never sampled
                        prior=c(prior(normal(0,1), class="b")))
```

### Fitting distance condition via brms

```{r Fitting distance as a continuous variable via brms}
# Computing brm for distance condition
set.seed(9578175)
distance_perceptual_coupling <- fit_prototype(perceptual_coupling_prototype, distance)
distance_independent_model <- fit_prototype(independent_prototype, distance)
distance_physics <- fit_prototype(physics_prototype, distance)
distance_pairwise_comparison <- fit_prototype(pairwise_comparison_prototype, distance, add_loo = FALSE)
```


### Compare models

```{r}
compare_models(distance_perceptual_coupling, distance_independent_model, distance_physics)
```

### Generate model predictions

```{r Distance as continuous predictions}
# predict GROUP-LEVEL Pcorotation
distance_fit_predictions <- predict(distance_perceptual_coupling,
                                    newdata = data.frame(Term = seq(-10, 70, 1)),
                                    probs = c(0.055, 0.25, 0.75, 0.945),
                                    re_formula = NA) %>%
  data.frame() %>%
  add_column(Term = seq(-10, 70, 1)) %>%
  rename(Distance = Term)
```

### Summary plot
```{r distance summary plot}
distance_plot <-
  ggplot(data=distance_fit_predictions, aes(x=Distance, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q5.5, ymax=Q94.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=distance, method="tukeyDense", width=2,
                  aes(x=Distance, group=Distance, y=Pcounterrotate)) +
  scale_x_continuous(name = "Distance (degrees)", breaks = unique(distance$Distance),
                     sec.axis =  dup_axis(name=NULL, labels=compute_factor_level_betas(distance_pairwise_comparison))) +
  scale_y_continuous(name="Pcounter-rotation") +
  plot_theme()

distance_plot
```


## Occlusion Condition

```{r occlusion data}
#Computing Occlusion Duration
occlusion<- reports%>%
  dplyr::filter(Condition=="Control"|Condition=="Occlusion") %>%
  dplyr::filter(Percept!="unclear") %>%
  
  # replace "None" with "0" and then turn Occlusion to a numeric variable
 dplyr:: mutate(Occlusion = ifelse(Occlusion == "None", "0", Occlusion), 
         Occlusion = as.numeric(Occlusion)) %>%
  # reorder Occlusion to factor
  # 1. Display to factor
 dplyr:: mutate(Display=as.factor(Display),
         OcclusionAsFactor=as.factor(Occlusion),
         OcclusionAsFactor=fct_relevel(OcclusionAsFactor, "0","8.13", "16.26", "32.52", "65.04")) %>%
  # 2. Use fct_relevel function, which goes Var = fct_relevel(Var, "first level", "second level", ...)
  # each participant and Occlusion seperatly
  dplyr::group_by(Participant, Occlusion, OcclusionAsFactor) %>% 
  dplyr::summarize(TotalDuration = sum(Duration),
           #if value in the brackets is true itll be considered if not it will not
            CounterrotateDur = sum(Duration[!IsCorotating]),
            Pcounterrotate = CounterrotateDur / TotalDuration)%>%
    # beta distribution does not like 0 and 1
 dplyr:: mutate(Padj = Pcounterrotate*0.999+0.0005)%>%
 # duplicating Occlusion as Term for common BRMS model use
  dplyr::mutate(Term = Occlusion,
                TermAsFactor = OcclusionAsFactor)%>%
  dplyr::mutate(NotInteracting= as.integer((0)))
  
```


```{r Fitting occlusion as a continuous variable via brms}
# Computing brm for occlusion condition
set.seed(9789931)
occlusion_perceptual_coupling <- fit_prototype(perceptual_coupling_prototype, occlusion)
occlusion_independent_model <- fit_prototype(independent_prototype, occlusion)
occlusion_physics<- fit_prototype(physics_prototype, occlusion)
occlusion_pairwise_comparison <- fit_prototype(pairwise_comparison_prototype, occlusion, add_loo = FALSE)
```

### Generate a full model summary for Occlusion
```{r}
# Compute estimates for individual parameters
occlusion_alpha <- compute_full_model_alpha(occlusion_perceptual_coupling)
occlusion_beta <- compute_full_model_beta(occlusion_perceptual_coupling)
```

```{r comparing models}
compare_models(occlusion_perceptual_coupling, occlusion_independent_model, occlusion_physics)
```

### Generate model predictions Occlusion

```{r Occlusion as continuous predictions}
# predict GROUP-LEVEL Pcorotation
occlusion_fit_predictions <- predict(occlusion_perceptual_coupling,
                                    newdata = data.frame(Term = seq(0, 70, 1)),
                                    probs = c(0.055, 0.25, 0.75, 0.945),
                                    re_formula = NA) %>%
  data.frame() %>%
  add_column(Term = seq(0, 70, 1)) %>%
  rename(Occlusion = Term)
```

### Summary plot Occlusion
```{r occlusion summary plot}
occlusion_plot <-
  ggplot(data=occlusion_fit_predictions, aes(x=Occlusion, y=Estimate)) + 
  geom_ribbon(aes(ymin=Q5.5, ymax=Q94.5), alpha= 0.25) + 
  geom_ribbon(aes(ymin=Q25, ymax=Q75), alpha= 0.25) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_quasirandom(data=occlusion, method="tukeyDense", width=2,
                  aes(x=Occlusion, group=Occlusion, y=Pcounterrotate)) +
  scale_x_continuous(name = "Occlusion (degrees)", breaks = unique(occlusion$Occlusion),
                     sec.axis =  dup_axis(name=NULL, labels=compute_factor_level_betas(occlusion_factor_model))) +
  scale_y_continuous(name="Pcounter-rotation") +
  plot_theme() +
  labs(subtitle=occlusion_summary)

occlusion_plot
```

## Ambiguity 

```{r}
##Computing Ambiguity Duration
ambiguity<- reports%>%
  filter(Condition=="Control"|Condition=="Ambiguity")%>% 
  filter(Percept!="unclear")%>%

    # each participant and Ambiguity seperatly
  group_by(Participant, Display)%>% 
  summarize(TotalDuration=sum(Duration),
          
              # if value in the brackets is true itll be considered if not it will not
              CounterrotateDur=sum(Duration[!IsCorotating]),
              Pcounterrotate=CounterrotateDur/TotalDuration) %>%
  mutate(Padj=Pcounterrotate*0.999+0.0005) %>%
  
  mutate(Term= Display)#used to be TermAsFactor
```

```{r fitting ambiguity}
set.seed(472832)
ambiguity_perceptual_coupling <- fit_prototype(perceptual_coupling_prototype, ambiguity)
ambiguity_independent_model <- fit_prototype(independent_prototype, ambiguity)
ambiguity_physics<- fit_prototype(physics_prototype, ambiguity)
ambiguity_pairwise_comparison <- fit_prototype(pairwise_comparison_prototype, ambiguity, add_loo = FALSE)
```

```{r comparing models ambiguity}
compare_models(ambiguity_perceptual_coupling, ambiguity_independent_model, ambiguity_physics)
```

```{r fitting ambiguity as factor}
set.seed(99435)
ambiguity_factor_model <- fit_prototype(pairwise_comparison_prototype, ambiguity)
ambiguity_intercept_model <- fit_prototype(independent_prototype, ambiguity)
```



Comparing the two models
```{r}
ambiguity_alpha <- compute_full_model_alpha(ambiguity_factor_model)
ambiguity_comparison <- compare_models(ambiguity_factor_model, ambiguity_intercept_model)
ambiguity_summary <- stringr::str_c(ambiguity_alpha, ambiguity_comparison, sep=", ")
ambiguity_summary
```
Generating predictions

```{r predicting and plotting ambiguity}
ambiguity_fit_predictions <- predict(ambiguity_factor_model,
                                     newdata = data.frame(TermAsFactor = levels(ambiguity$Display)),
                                     summary = FALSE,
                                     re_formula = NA) %>%
  data.frame() %>%
  pivot_longer(everything(), names_to = "Display", values_to = "Pcounterrotate") %>%
  mutate(Display = factor(Display, levels = sort(unique(Display)), labels = levels(ambiguity$Display)))
  

ambiguity_fit_moments <-
  ambiguity_fit_predictions %>%
  group_by(Display) %>%
  summarise(meanP = mean(Pcounterrotate),
            medianP= median(Pcounterrotate))


```


```{r plotting ambiguity}
ambiguity_plot <-
  ggplot(data=ambiguity_fit_predictions, 
      aes(x = as.numeric(Display), group=Display, y=Pcounterrotate)) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_violin(data = ambiguity_fit_predictions, aes(x=as.numeric(Display)), 
              fill="gray64", color="white", draw_quantiles = c(0.5)) +
  geom_quasirandom(data=ambiguity, method="tukeyDense", width=0.1,
                aes(x=as.numeric(Display), group=Display, y=Pcounterrotate)) +
  scale_x_continuous(name="Display",
                     breaks = unique(as.numeric(ambiguity$Display)),
                     labels = c("ambiguous","weak", "medium","medium-strong","strong"),
                     sec.axis =  dup_axis(name = element_blank(),
                                          labels = compute_factor_level_betas(ambiguity_factor_model)))+
  scale_y_continuous(name="Pcounter-rotation") +
  plot_theme() +
  labs(subtitle=ambiguity_summary)

ambiguity_plot
```

## All plots together

```{r}
distance_plot / occlusion_plot / ambiguity_plot + 
  plot_annotation(tag_levels= "A")

ggsave('figure-02-gears.pdf', width=14, height=20, units="cm", device=cairo_pdf)
ggsave('figure-02-gears.png', width=14, height=20, units="cm")
ggsave('figure-02-gears.svg', width=14, height=20, units="cm")
```


## Disambiguation effectiveness check
```{r}
disambiguation<- reports%>%
  filter(Condition=="Control"|Condition=="Ambiguity")%>% 
  filter(Percept!="unclear")%>%
  
  group_by(Participant, Display)%>% 
  summarize(TotalDuration=sum(Duration),
            ClockwiseDur=sum(Duration[PrimeGear=="CW"]),
    Pclockwise=ClockwiseDur/TotalDuration)%>%
mutate(Padj=Pclockwise*0.999+0.0005)%>%
mutate(TermAsFactor = Display)
```


```{r fitting disambiguation as factor}
set.seed(31937)
disambiguation_factor_model <- fit_prototype(pairwise_comparison_prototype, disambiguation)
disambiguation_intercept_model <- fit_prototype(independent_prototype, disambiguation)
```

```{r comparing the disambiguation models}
disambiguation_alpha <- compute_full_model_alpha(disambiguation_factor_model)
disambiguation_comparison <- compare_models(disambiguation_factor_model, disambiguation_intercept_model)
disambiguation_summary <- stringr::str_c(disambiguation_alpha, disambiguation_comparison, sep=", ")
disambiguation_summary
```

```{r predicting and plotting ambiguity}
disambiguation_fit_predictions <- predict(disambiguation_factor_model,
                                     newdata = data.frame(TermAsFactor = levels(disambiguation$Display)),
                                     summary = FALSE,
                                     re_formula = NA) %>%
  data.frame() %>%
  pivot_longer(everything(), names_to = "Display", values_to = "Pclockwise") %>%
  mutate(Display = factor(Display, levels = sort(unique(Display)), labels = levels(disambiguation$Display)))
  

disambiguation_fit_moments <-
  disambiguation_fit_predictions %>%
  group_by(Display) %>%
  summarise(meanP = mean(Pclockwise),
            medianP= median(Pclockwise))


```

```{r plotting disambiguation}
disambiguation_plot_main <-
  ggplot(data=disambiguation_fit_predictions, 
      aes(x = as.numeric(Display), group=Display, y=Pclockwise)) + 
  geom_line() +
  geom_hline(yintercept = 0.5, color="white", size= 1) +
  geom_violin(data = disambiguation_fit_predictions, aes(x=as.numeric(Display)), 
              fill="gray64", color="white", draw_quantiles = c(0.5)) +
  geom_quasirandom(data=disambiguation, method="tukeyDense", width=0.1,
                aes(x=as.numeric(Display), group=Display, y=Pclockwise)) +
  scale_x_continuous(name="Display (degrees)",
                     breaks = unique(as.numeric(disambiguation$Display)),
                     labels = c("ambiguous","weak", "medium","medium-strong","strong"),
                     sec.axis =  dup_axis(name = element_blank(),
                                          labels = compute_factor_level_betas(disambiguation_factor_model)))+
  scale_y_continuous(name="Pclockwise") +
  plot_theme() +
  labs(subtitle=disambiguation_summary)

disambiguation_plot_main

ggsave("figure-s01.png", units="cm", width=14, height=7)
ggsave("figure-s01.pdf", units="cm", width=14, height=7, device=cairo_pdf)
ggsave("figure-s01.svg", units="cm", width=14, height=7)
```

